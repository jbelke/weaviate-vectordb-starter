{
info: {
_postman_id: "062131f7-0826-49e8-bb4d-329a8e1da35d",
name: "Weaviate",
description: "# Introduction

Weaviate is an open source, AI-native vector database that helps developers create intuitive and reliable AI-powered applications.

### Base Path

The base path for the Weaviate server is structured as `[YOUR-WEAVIATE-HOST]:[PORT]/v1`. As an example, if you wish to access the `schema` endpoint on a local instance, you would navigate to `http://localhost:9080/v1/schema`. Ensure you replace `[YOUR-WEAVIATE-HOST]` and `[PORT]` with your actual server host and port number respectively.

### Questions?

If you have any comments or questions, please feel free to reach out to us at the community forum [https://forum.weaviate.io/](https://forum.weaviate.io/).

### Issues?

If you find a bug or want to file a feature request, please open an issue on our GitHub repository for [Weaviate](https://github.com/weaviate/weaviate).

### Want more documentation?

For a quickstart, code examples, concepts and more, please visit our [documentation page](https://weaviate.io/developers/weaviate).

Contact Support:  
Name: Weaviate",
schema: "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
_exporter_id: "21155610"
},
item: [
{
name: "/",
item: [
{
name: "List available endpoints",
request: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/",
host: [
"{{baseUrl}}"
],
path: [
""
]
},
description: "Get links to other endpoints to help discover the REST API"
},
response: [
{
name: "Weaviate is alive and ready to serve content",
originalRequest: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/",
host: [
"{{baseUrl}}"
],
path: [
""
]
}
},
status: "OK",
code: 200,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "links": [
    {
      "href": "<string>",
      "rel": "<string>",
      "name": "<string>",
      "documentationHref": "<string>"
    },
    {
      "href": "<string>",
      "rel": "<string>",
      "name": "<string>",
      "documentationHref": "<string>"
    }
  ]
}"
}
]
}
]
},
{
name: ".well-known",
item: [
{
name: "live",
item: [
{
name: "Get application liveness.",
request: {
method: "GET",
header: [ ],
url: {
raw: "{{baseUrl}}/.well-known/live",
host: [
"{{baseUrl}}"
],
path: [
".well-known",
"live"
]
},
description: "Determines whether the application is alive. Can be used for kubernetes liveness probe"
},
response: [
{
name: "The application is able to respond to HTTP requests",
originalRequest: {
method: "GET",
header: [ ],
url: {
raw: "{{baseUrl}}/.well-known/live",
host: [
"{{baseUrl}}"
],
path: [
".well-known",
"live"
]
}
},
status: "OK",
code: 200,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
}
]
}
]
},
{
name: "ready",
item: [
{
name: "Get application readiness.",
request: {
method: "GET",
header: [ ],
url: {
raw: "{{baseUrl}}/.well-known/ready",
host: [
"{{baseUrl}}"
],
path: [
".well-known",
"ready"
]
},
description: "Determines whether the application is ready to receive traffic. Can be used for kubernetes readiness probe."
},
response: [
{
name: "The application has completed its start-up routine and is ready to accept traffic.",
originalRequest: {
method: "GET",
header: [ ],
url: {
raw: "{{baseUrl}}/.well-known/ready",
host: [
"{{baseUrl}}"
],
path: [
".well-known",
"ready"
]
}
},
status: "OK",
code: 200,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "The application is currently not able to serve traffic. If other horizontal replicas of weaviate are available and they are capable of receiving traffic, all traffic should be redirected there instead.",
originalRequest: {
method: "GET",
header: [ ],
url: {
raw: "{{baseUrl}}/.well-known/ready",
host: [
"{{baseUrl}}"
],
path: [
".well-known",
"ready"
]
}
},
status: "Service Unavailable",
code: 503,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
}
]
}
]
},
{
name: "openid-configuration",
item: [
{
name: "OIDC discovery information (if OIDC auth is enabled)",
request: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/.well-known/openid-configuration",
host: [
"{{baseUrl}}"
],
path: [
".well-known",
"openid-configuration"
]
},
description: "OIDC Discovery page, redirects to the token issuer if one is configured"
},
response: [
{
name: "Successful response, inspect body",
originalRequest: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/.well-known/openid-configuration",
host: [
"{{baseUrl}}"
],
path: [
".well-known",
"openid-configuration"
]
}
},
status: "OK",
code: 200,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "href": "<string>",
  "clientId": "<string>",
  "scopes": [
    "<string>",
    "<string>"
  ]
}"
},
{
name: "Not found, no oidc provider present",
originalRequest: {
method: "GET",
header: [ ],
url: {
raw: "{{baseUrl}}/.well-known/openid-configuration",
host: [
"{{baseUrl}}"
],
path: [
".well-known",
"openid-configuration"
]
}
},
status: "Not Found",
code: 404,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error.",
originalRequest: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/.well-known/openid-configuration",
host: [
"{{baseUrl}}"
],
path: [
".well-known",
"openid-configuration"
]
}
},
status: "Internal Server Error",
code: 500,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
}
]
}
]
}
]
},
{
name: "objects",
item: [
{
name: "{id}",
item: [
{
name: "references",
item: [
{
name: "{propertyName}",
item: [
{
name: "Add a cross-reference.",
request: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<uri>",
  "schema": {},
  "beacon": "<uri>",
  "href": "<uri>",
  "classification": {
    "overallCount": "<number>",
    "winningCount": "<number>",
    "losingCount": "<number>",
    "closestOverallDistance": "<number>",
    "winningDistance": "<number>",
    "meanWinningDistance": "<number>",
    "closestWinningDistance": "<number>",
    "closestLosingDistance": "<number>",
    "losingDistance": "<number>",
    "meanLosingDistance": "<number>"
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:id/references/:propertyName?tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":id",
"references",
":propertyName"
],
query: [
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "id",
value: "<uuid>",
description: "(Required) Unique ID of the Object."
},
{
key: "propertyName",
value: "<string>",
description: "(Required) Unique name of the property related to the Object."
}
]
},
description: "Add a cross-reference."
},
response: [
{
name: "Successfully added the reference.",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<uri>",
  "schema": {},
  "beacon": "<uri>",
  "href": "<uri>",
  "classification": {
    "overallCount": "<number>",
    "winningCount": "<number>",
    "losingCount": "<number>",
    "closestOverallDistance": "<number>",
    "winningDistance": "<number>",
    "meanWinningDistance": "<number>",
    "closestWinningDistance": "<number>",
    "closestLosingDistance": "<number>",
    "losingDistance": "<number>",
    "meanLosingDistance": "<number>"
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:id/references/:propertyName?tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":id",
"references",
":propertyName"
],
query: [
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "id"
},
{
key: "propertyName"
}
]
}
},
status: "OK",
code: 200,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Unauthorized or invalid credentials.",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<uri>",
  "schema": {},
  "beacon": "<uri>",
  "href": "<uri>",
  "classification": {
    "overallCount": "<number>",
    "winningCount": "<number>",
    "losingCount": "<number>",
    "closestOverallDistance": "<number>",
    "winningDistance": "<number>",
    "meanWinningDistance": "<number>",
    "closestWinningDistance": "<number>",
    "closestLosingDistance": "<number>",
    "losingDistance": "<number>",
    "meanLosingDistance": "<number>"
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:id/references/:propertyName?tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":id",
"references",
":propertyName"
],
query: [
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "id"
},
{
key: "propertyName"
}
]
}
},
status: "Unauthorized",
code: 401,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Forbidden",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<uri>",
  "schema": {},
  "beacon": "<uri>",
  "href": "<uri>",
  "classification": {
    "overallCount": "<number>",
    "winningCount": "<number>",
    "losingCount": "<number>",
    "closestOverallDistance": "<number>",
    "winningDistance": "<number>",
    "meanWinningDistance": "<number>",
    "closestWinningDistance": "<number>",
    "closestLosingDistance": "<number>",
    "losingDistance": "<number>",
    "meanLosingDistance": "<number>"
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:id/references/:propertyName?tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":id",
"references",
":propertyName"
],
query: [
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "id"
},
{
key: "propertyName"
}
]
}
},
status: "Forbidden",
code: 403,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Request body is well-formed (i.e., syntactically correct), but semantically erroneous. Are you sure the property exists or that it is a class?",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<uri>",
  "schema": {},
  "beacon": "<uri>",
  "href": "<uri>",
  "classification": {
    "overallCount": "<number>",
    "winningCount": "<number>",
    "losingCount": "<number>",
    "closestOverallDistance": "<number>",
    "winningDistance": "<number>",
    "meanWinningDistance": "<number>",
    "closestWinningDistance": "<number>",
    "closestLosingDistance": "<number>",
    "losingDistance": "<number>",
    "meanLosingDistance": "<number>"
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:id/references/:propertyName?tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":id",
"references",
":propertyName"
],
query: [
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "id"
},
{
key: "propertyName"
}
]
}
},
status: "Unprocessable Entity (WebDAV) (RFC 4918)",
code: 422,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error.",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<uri>",
  "schema": {},
  "beacon": "<uri>",
  "href": "<uri>",
  "classification": {
    "overallCount": "<number>",
    "winningCount": "<number>",
    "losingCount": "<number>",
    "closestOverallDistance": "<number>",
    "winningDistance": "<number>",
    "meanWinningDistance": "<number>",
    "closestWinningDistance": "<number>",
    "closestLosingDistance": "<number>",
    "losingDistance": "<number>",
    "meanLosingDistance": "<number>"
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:id/references/:propertyName?tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":id",
"references",
":propertyName"
],
query: [
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "id"
},
{
key: "propertyName"
}
]
}
},
status: "Internal Server Error",
code: 500,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
}
]
},
{
name: "Replace cross-references.",
request: {
method: "PUT",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "[
  {
    "class": "<uri>",
    "schema": {},
    "beacon": "<uri>",
    "href": "<uri>",
    "classification": {
      "overallCount": "<number>",
      "winningCount": "<number>",
      "losingCount": "<number>",
      "closestOverallDistance": "<number>",
      "winningDistance": "<number>",
      "meanWinningDistance": "<number>",
      "closestWinningDistance": "<number>",
      "closestLosingDistance": "<number>",
      "losingDistance": "<number>",
      "meanLosingDistance": "<number>"
    }
  },
  {
    "class": "<uri>",
    "schema": {},
    "beacon": "<uri>",
    "href": "<uri>",
    "classification": {
      "overallCount": "<number>",
      "winningCount": "<number>",
      "losingCount": "<number>",
      "closestOverallDistance": "<number>",
      "winningDistance": "<number>",
      "meanWinningDistance": "<number>",
      "closestWinningDistance": "<number>",
      "closestLosingDistance": "<number>",
      "losingDistance": "<number>",
      "meanLosingDistance": "<number>"
    }
  }
]",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:id/references/:propertyName?tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":id",
"references",
":propertyName"
],
query: [
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "id",
value: "<uuid>",
description: "(Required) Unique ID of the Object."
},
{
key: "propertyName",
value: "<string>",
description: "(Required) Unique name of the property related to the Object."
}
]
},
description: "Replace all references in cross-reference property of an object."
},
response: [
{
name: "Successfully replaced all the references.",
originalRequest: {
method: "PUT",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "[
  {
    "class": "<uri>",
    "schema": {},
    "beacon": "<uri>",
    "href": "<uri>",
    "classification": {
      "overallCount": "<number>",
      "winningCount": "<number>",
      "losingCount": "<number>",
      "closestOverallDistance": "<number>",
      "winningDistance": "<number>",
      "meanWinningDistance": "<number>",
      "closestWinningDistance": "<number>",
      "closestLosingDistance": "<number>",
      "losingDistance": "<number>",
      "meanLosingDistance": "<number>"
    }
  },
  {
    "class": "<uri>",
    "schema": {},
    "beacon": "<uri>",
    "href": "<uri>",
    "classification": {
      "overallCount": "<number>",
      "winningCount": "<number>",
      "losingCount": "<number>",
      "closestOverallDistance": "<number>",
      "winningDistance": "<number>",
      "meanWinningDistance": "<number>",
      "closestWinningDistance": "<number>",
      "closestLosingDistance": "<number>",
      "losingDistance": "<number>",
      "meanLosingDistance": "<number>"
    }
  }
]",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:id/references/:propertyName?tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":id",
"references",
":propertyName"
],
query: [
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "id"
},
{
key: "propertyName"
}
]
}
},
status: "OK",
code: 200,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Unauthorized or invalid credentials.",
originalRequest: {
method: "PUT",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "[
  {
    "class": "<uri>",
    "schema": {},
    "beacon": "<uri>",
    "href": "<uri>",
    "classification": {
      "overallCount": "<number>",
      "winningCount": "<number>",
      "losingCount": "<number>",
      "closestOverallDistance": "<number>",
      "winningDistance": "<number>",
      "meanWinningDistance": "<number>",
      "closestWinningDistance": "<number>",
      "closestLosingDistance": "<number>",
      "losingDistance": "<number>",
      "meanLosingDistance": "<number>"
    }
  },
  {
    "class": "<uri>",
    "schema": {},
    "beacon": "<uri>",
    "href": "<uri>",
    "classification": {
      "overallCount": "<number>",
      "winningCount": "<number>",
      "losingCount": "<number>",
      "closestOverallDistance": "<number>",
      "winningDistance": "<number>",
      "meanWinningDistance": "<number>",
      "closestWinningDistance": "<number>",
      "closestLosingDistance": "<number>",
      "losingDistance": "<number>",
      "meanLosingDistance": "<number>"
    }
  }
]",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:id/references/:propertyName?tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":id",
"references",
":propertyName"
],
query: [
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "id"
},
{
key: "propertyName"
}
]
}
},
status: "Unauthorized",
code: 401,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Forbidden",
originalRequest: {
method: "PUT",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "[
  {
    "class": "<uri>",
    "schema": {},
    "beacon": "<uri>",
    "href": "<uri>",
    "classification": {
      "overallCount": "<number>",
      "winningCount": "<number>",
      "losingCount": "<number>",
      "closestOverallDistance": "<number>",
      "winningDistance": "<number>",
      "meanWinningDistance": "<number>",
      "closestWinningDistance": "<number>",
      "closestLosingDistance": "<number>",
      "losingDistance": "<number>",
      "meanLosingDistance": "<number>"
    }
  },
  {
    "class": "<uri>",
    "schema": {},
    "beacon": "<uri>",
    "href": "<uri>",
    "classification": {
      "overallCount": "<number>",
      "winningCount": "<number>",
      "losingCount": "<number>",
      "closestOverallDistance": "<number>",
      "winningDistance": "<number>",
      "meanWinningDistance": "<number>",
      "closestWinningDistance": "<number>",
      "closestLosingDistance": "<number>",
      "losingDistance": "<number>",
      "meanLosingDistance": "<number>"
    }
  }
]",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:id/references/:propertyName?tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":id",
"references",
":propertyName"
],
query: [
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "id"
},
{
key: "propertyName"
}
]
}
},
status: "Forbidden",
code: 403,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Request body is well-formed (i.e., syntactically correct), but semantically erroneous. Are you sure the property exists or that it is a class?",
originalRequest: {
method: "PUT",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "[
  {
    "class": "<uri>",
    "schema": {},
    "beacon": "<uri>",
    "href": "<uri>",
    "classification": {
      "overallCount": "<number>",
      "winningCount": "<number>",
      "losingCount": "<number>",
      "closestOverallDistance": "<number>",
      "winningDistance": "<number>",
      "meanWinningDistance": "<number>",
      "closestWinningDistance": "<number>",
      "closestLosingDistance": "<number>",
      "losingDistance": "<number>",
      "meanLosingDistance": "<number>"
    }
  },
  {
    "class": "<uri>",
    "schema": {},
    "beacon": "<uri>",
    "href": "<uri>",
    "classification": {
      "overallCount": "<number>",
      "winningCount": "<number>",
      "losingCount": "<number>",
      "closestOverallDistance": "<number>",
      "winningDistance": "<number>",
      "meanWinningDistance": "<number>",
      "closestWinningDistance": "<number>",
      "closestLosingDistance": "<number>",
      "losingDistance": "<number>",
      "meanLosingDistance": "<number>"
    }
  }
]",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:id/references/:propertyName?tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":id",
"references",
":propertyName"
],
query: [
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "id"
},
{
key: "propertyName"
}
]
}
},
status: "Unprocessable Entity (WebDAV) (RFC 4918)",
code: 422,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error.",
originalRequest: {
method: "PUT",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "[
  {
    "class": "<uri>",
    "schema": {},
    "beacon": "<uri>",
    "href": "<uri>",
    "classification": {
      "overallCount": "<number>",
      "winningCount": "<number>",
      "losingCount": "<number>",
      "closestOverallDistance": "<number>",
      "winningDistance": "<number>",
      "meanWinningDistance": "<number>",
      "closestWinningDistance": "<number>",
      "closestLosingDistance": "<number>",
      "losingDistance": "<number>",
      "meanLosingDistance": "<number>"
    }
  },
  {
    "class": "<uri>",
    "schema": {},
    "beacon": "<uri>",
    "href": "<uri>",
    "classification": {
      "overallCount": "<number>",
      "winningCount": "<number>",
      "losingCount": "<number>",
      "closestOverallDistance": "<number>",
      "winningDistance": "<number>",
      "meanWinningDistance": "<number>",
      "closestWinningDistance": "<number>",
      "closestLosingDistance": "<number>",
      "losingDistance": "<number>",
      "meanLosingDistance": "<number>"
    }
  }
]",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:id/references/:propertyName?tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":id",
"references",
":propertyName"
],
query: [
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "id"
},
{
key: "propertyName"
}
]
}
},
status: "Internal Server Error",
code: 500,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
}
]
},
{
name: "Delete a cross-reference.",
request: {
method: "DELETE",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<uri>",
  "schema": {},
  "beacon": "<uri>",
  "href": "<uri>",
  "classification": {
    "overallCount": "<number>",
    "winningCount": "<number>",
    "losingCount": "<number>",
    "closestOverallDistance": "<number>",
    "winningDistance": "<number>",
    "meanWinningDistance": "<number>",
    "closestWinningDistance": "<number>",
    "closestLosingDistance": "<number>",
    "losingDistance": "<number>",
    "meanLosingDistance": "<number>"
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:id/references/:propertyName?tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":id",
"references",
":propertyName"
],
query: [
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "id",
value: "<uuid>",
description: "(Required) Unique ID of the Object."
},
{
key: "propertyName",
value: "<string>",
description: "(Required) Unique name of the property related to the Object."
}
]
},
description: "Delete the single reference that is given in the body from the list of references that this property has."
},
response: [
{
name: "Successfully deleted.",
originalRequest: {
method: "DELETE",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<uri>",
  "schema": {},
  "beacon": "<uri>",
  "href": "<uri>",
  "classification": {
    "overallCount": "<number>",
    "winningCount": "<number>",
    "losingCount": "<number>",
    "closestOverallDistance": "<number>",
    "winningDistance": "<number>",
    "meanWinningDistance": "<number>",
    "closestWinningDistance": "<number>",
    "closestLosingDistance": "<number>",
    "losingDistance": "<number>",
    "meanLosingDistance": "<number>"
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:id/references/:propertyName?tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":id",
"references",
":propertyName"
],
query: [
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "id"
},
{
key: "propertyName"
}
]
}
},
status: "No Content",
code: 204,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Unauthorized or invalid credentials.",
originalRequest: {
method: "DELETE",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<uri>",
  "schema": {},
  "beacon": "<uri>",
  "href": "<uri>",
  "classification": {
    "overallCount": "<number>",
    "winningCount": "<number>",
    "losingCount": "<number>",
    "closestOverallDistance": "<number>",
    "winningDistance": "<number>",
    "meanWinningDistance": "<number>",
    "closestWinningDistance": "<number>",
    "closestLosingDistance": "<number>",
    "losingDistance": "<number>",
    "meanLosingDistance": "<number>"
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:id/references/:propertyName?tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":id",
"references",
":propertyName"
],
query: [
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "id"
},
{
key: "propertyName"
}
]
}
},
status: "Unauthorized",
code: 401,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Forbidden",
originalRequest: {
method: "DELETE",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<uri>",
  "schema": {},
  "beacon": "<uri>",
  "href": "<uri>",
  "classification": {
    "overallCount": "<number>",
    "winningCount": "<number>",
    "losingCount": "<number>",
    "closestOverallDistance": "<number>",
    "winningDistance": "<number>",
    "meanWinningDistance": "<number>",
    "closestWinningDistance": "<number>",
    "closestLosingDistance": "<number>",
    "losingDistance": "<number>",
    "meanLosingDistance": "<number>"
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:id/references/:propertyName?tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":id",
"references",
":propertyName"
],
query: [
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "id"
},
{
key: "propertyName"
}
]
}
},
status: "Forbidden",
code: 403,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Successful query result but no resource was found.",
originalRequest: {
method: "DELETE",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<uri>",
  "schema": {},
  "beacon": "<uri>",
  "href": "<uri>",
  "classification": {
    "overallCount": "<number>",
    "winningCount": "<number>",
    "losingCount": "<number>",
    "closestOverallDistance": "<number>",
    "winningDistance": "<number>",
    "meanWinningDistance": "<number>",
    "closestWinningDistance": "<number>",
    "closestLosingDistance": "<number>",
    "losingDistance": "<number>",
    "meanLosingDistance": "<number>"
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:id/references/:propertyName?tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":id",
"references",
":propertyName"
],
query: [
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "id"
},
{
key: "propertyName"
}
]
}
},
status: "Not Found",
code: 404,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error.",
originalRequest: {
method: "DELETE",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<uri>",
  "schema": {},
  "beacon": "<uri>",
  "href": "<uri>",
  "classification": {
    "overallCount": "<number>",
    "winningCount": "<number>",
    "losingCount": "<number>",
    "closestOverallDistance": "<number>",
    "winningDistance": "<number>",
    "meanWinningDistance": "<number>",
    "closestWinningDistance": "<number>",
    "closestLosingDistance": "<number>",
    "losingDistance": "<number>",
    "meanLosingDistance": "<number>"
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:id/references/:propertyName?tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":id",
"references",
":propertyName"
],
query: [
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "id"
},
{
key: "propertyName"
}
]
}
},
status: "Internal Server Error",
code: 500,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
}
]
}
]
}
]
},
{
name: "Delete an object.",
request: {
method: "DELETE",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/objects/:id?consistency_level=QUORUM&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":id"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "id",
value: "<uuid>",
description: "(Required) Unique ID of the Object."
}
]
},
description: "Deletes an object from the database based on its UUID."
},
response: [
{
name: "Successfully deleted.",
originalRequest: {
method: "DELETE",
header: [ ],
url: {
raw: "{{baseUrl}}/objects/:id?consistency_level=QUORUM&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":id"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "id"
}
]
}
},
status: "No Content",
code: 204,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Unauthorized or invalid credentials.",
originalRequest: {
method: "DELETE",
header: [ ],
url: {
raw: "{{baseUrl}}/objects/:id?consistency_level=QUORUM&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":id"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "id"
}
]
}
},
status: "Unauthorized",
code: 401,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Forbidden",
originalRequest: {
method: "DELETE",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/objects/:id?consistency_level=QUORUM&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":id"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "id"
}
]
}
},
status: "Forbidden",
code: 403,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Successful query result but no resource was found.",
originalRequest: {
method: "DELETE",
header: [ ],
url: {
raw: "{{baseUrl}}/objects/:id?consistency_level=QUORUM&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":id"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "id"
}
]
}
},
status: "Not Found",
code: 404,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error.",
originalRequest: {
method: "DELETE",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/objects/:id?consistency_level=QUORUM&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":id"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "id"
}
]
}
},
status: "Internal Server Error",
code: 500,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
}
]
},
{
name: "List objects.",
request: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/objects/:id?include=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":id"
],
query: [
{
key: "include",
value: "<string>",
description: "Include additional information, such as classification infos. Allowed values include: `classification`, `vector`, `interpretation`, `featureProjection` and other module-specific additional properties."
}
],
variable: [
{
key: "id",
value: "<uuid>",
description: "(Required) Unique ID of the Object."
}
]
},
description: "Get a specific object based on its UUID. Also available as Websocket bus."
},
response: [
{
name: "Successful response.",
originalRequest: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/objects/:id?include=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":id"
],
query: [
{
key: "include",
value: "<string>",
description: "Include additional information, such as classification infos. Allowed values include: `classification`, `vector`, `interpretation`, `featureProjection` and other module-specific additional properties."
}
],
variable: [
{
key: "id"
}
]
}
},
status: "OK",
code: 200,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "class": "<string>",
  "vectorWeights": {},
  "properties": {},
  "id": "<uuid>",
  "creationTimeUnix": "<long>",
  "lastUpdateTimeUnix": "<long>",
  "vector": [
    "<float>",
    "<float>"
  ],
  "vectors": {
    "sint_b38": [
      "<float>",
      "<float>"
    ]
  },
  "tenant": "<string>",
  "additional": {
    "enim9": {},
    "sunt_6a": {},
    "voluptate_e": {}
  }
}"
},
{
name: "Malformed request.",
originalRequest: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/objects/:id?include=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":id"
],
query: [
{
key: "include",
value: "<string>",
description: "Include additional information, such as classification infos. Allowed values include: `classification`, `vector`, `interpretation`, `featureProjection` and other module-specific additional properties."
}
],
variable: [
{
key: "id"
}
]
}
},
status: "Bad Request",
code: 400,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Unauthorized or invalid credentials.",
originalRequest: {
method: "GET",
header: [ ],
url: {
raw: "{{baseUrl}}/objects/:id?include=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":id"
],
query: [
{
key: "include",
value: "<string>",
description: "Include additional information, such as classification infos. Allowed values include: `classification`, `vector`, `interpretation`, `featureProjection` and other module-specific additional properties."
}
],
variable: [
{
key: "id"
}
]
}
},
status: "Unauthorized",
code: 401,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Forbidden",
originalRequest: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/objects/:id?include=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":id"
],
query: [
{
key: "include",
value: "<string>",
description: "Include additional information, such as classification infos. Allowed values include: `classification`, `vector`, `interpretation`, `featureProjection` and other module-specific additional properties."
}
],
variable: [
{
key: "id"
}
]
}
},
status: "Forbidden",
code: 403,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Successful query result but no resource was found.",
originalRequest: {
method: "GET",
header: [ ],
url: {
raw: "{{baseUrl}}/objects/:id?include=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":id"
],
query: [
{
key: "include",
value: "<string>",
description: "Include additional information, such as classification infos. Allowed values include: `classification`, `vector`, `interpretation`, `featureProjection` and other module-specific additional properties."
}
],
variable: [
{
key: "id"
}
]
}
},
status: "Not Found",
code: 404,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error.",
originalRequest: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/objects/:id?include=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":id"
],
query: [
{
key: "include",
value: "<string>",
description: "Include additional information, such as classification infos. Allowed values include: `classification`, `vector`, `interpretation`, `featureProjection` and other module-specific additional properties."
}
],
variable: [
{
key: "id"
}
]
}
},
status: "Internal Server Error",
code: 500,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
}
]
},
{
name: "Update an object using patch semantics.",
request: {
method: "PATCH",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<string>",
  "vectorWeights": {},
  "properties": {},
  "id": "<uuid>",
  "creationTimeUnix": "<long>",
  "lastUpdateTimeUnix": "<long>",
  "vector": [
    "<float>",
    "<float>"
  ],
  "vectors": {
    "sint_b38": [
      "<float>",
      "<float>"
    ]
  },
  "tenant": "<string>",
  "additional": {
    "enim9": {},
    "sunt_6a": {},
    "voluptate_e": {}
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:id?consistency_level=QUORUM",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":id"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
}
],
variable: [
{
key: "id",
value: "<uuid>",
description: "(Required) Unique ID of the Object."
}
]
},
description: "Update an object based on its UUID (using patch semantics). This method supports json-merge style patch semantics (RFC 7396). Provided meta-data and schema values are validated. LastUpdateTime is set to the time this function is called."
},
response: [
{
name: "Successfully applied. No content provided.",
originalRequest: {
method: "PATCH",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<string>",
  "vectorWeights": {},
  "properties": {},
  "id": "<uuid>",
  "creationTimeUnix": "<long>",
  "lastUpdateTimeUnix": "<long>",
  "vector": [
    "<float>",
    "<float>"
  ],
  "vectors": {
    "sint_b38": [
      "<float>",
      "<float>"
    ]
  },
  "tenant": "<string>",
  "additional": {
    "enim9": {},
    "sunt_6a": {},
    "voluptate_e": {}
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:id?consistency_level=QUORUM",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":id"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
}
],
variable: [
{
key: "id"
}
]
}
},
status: "No Content",
code: 204,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "The patch-JSON is malformed.",
originalRequest: {
method: "PATCH",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<string>",
  "vectorWeights": {},
  "properties": {},
  "id": "<uuid>",
  "creationTimeUnix": "<long>",
  "lastUpdateTimeUnix": "<long>",
  "vector": [
    "<float>",
    "<float>"
  ],
  "vectors": {
    "sint_b38": [
      "<float>",
      "<float>"
    ]
  },
  "tenant": "<string>",
  "additional": {
    "enim9": {},
    "sunt_6a": {},
    "voluptate_e": {}
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:id?consistency_level=QUORUM",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":id"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
}
],
variable: [
{
key: "id"
}
]
}
},
status: "Bad Request",
code: 400,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Unauthorized or invalid credentials.",
originalRequest: {
method: "PATCH",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<string>",
  "vectorWeights": {},
  "properties": {},
  "id": "<uuid>",
  "creationTimeUnix": "<long>",
  "lastUpdateTimeUnix": "<long>",
  "vector": [
    "<float>",
    "<float>"
  ],
  "vectors": {
    "sint_b38": [
      "<float>",
      "<float>"
    ]
  },
  "tenant": "<string>",
  "additional": {
    "enim9": {},
    "sunt_6a": {},
    "voluptate_e": {}
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:id?consistency_level=QUORUM",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":id"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
}
],
variable: [
{
key: "id"
}
]
}
},
status: "Unauthorized",
code: 401,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Forbidden",
originalRequest: {
method: "PATCH",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<string>",
  "vectorWeights": {},
  "properties": {},
  "id": "<uuid>",
  "creationTimeUnix": "<long>",
  "lastUpdateTimeUnix": "<long>",
  "vector": [
    "<float>",
    "<float>"
  ],
  "vectors": {
    "sint_b38": [
      "<float>",
      "<float>"
    ]
  },
  "tenant": "<string>",
  "additional": {
    "enim9": {},
    "sunt_6a": {},
    "voluptate_e": {}
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:id?consistency_level=QUORUM",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":id"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
}
],
variable: [
{
key: "id"
}
]
}
},
status: "Forbidden",
code: 403,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Successful query result but no resource was found.",
originalRequest: {
method: "PATCH",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<string>",
  "vectorWeights": {},
  "properties": {},
  "id": "<uuid>",
  "creationTimeUnix": "<long>",
  "lastUpdateTimeUnix": "<long>",
  "vector": [
    "<float>",
    "<float>"
  ],
  "vectors": {
    "sint_b38": [
      "<float>",
      "<float>"
    ]
  },
  "tenant": "<string>",
  "additional": {
    "enim9": {},
    "sunt_6a": {},
    "voluptate_e": {}
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:id?consistency_level=QUORUM",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":id"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
}
],
variable: [
{
key: "id"
}
]
}
},
status: "Not Found",
code: 404,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "The patch-JSON is valid but unprocessable.",
originalRequest: {
method: "PATCH",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<string>",
  "vectorWeights": {},
  "properties": {},
  "id": "<uuid>",
  "creationTimeUnix": "<long>",
  "lastUpdateTimeUnix": "<long>",
  "vector": [
    "<float>",
    "<float>"
  ],
  "vectors": {
    "sint_b38": [
      "<float>",
      "<float>"
    ]
  },
  "tenant": "<string>",
  "additional": {
    "enim9": {},
    "sunt_6a": {},
    "voluptate_e": {}
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:id?consistency_level=QUORUM",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":id"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
}
],
variable: [
{
key: "id"
}
]
}
},
status: "Unprocessable Entity (WebDAV) (RFC 4918)",
code: 422,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error.",
originalRequest: {
method: "PATCH",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<string>",
  "vectorWeights": {},
  "properties": {},
  "id": "<uuid>",
  "creationTimeUnix": "<long>",
  "lastUpdateTimeUnix": "<long>",
  "vector": [
    "<float>",
    "<float>"
  ],
  "vectors": {
    "sint_b38": [
      "<float>",
      "<float>"
    ]
  },
  "tenant": "<string>",
  "additional": {
    "enim9": {},
    "sunt_6a": {},
    "voluptate_e": {}
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:id?consistency_level=QUORUM",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":id"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
}
],
variable: [
{
key: "id"
}
]
}
},
status: "Internal Server Error",
code: 500,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
}
]
},
{
name: "Update an object.",
request: {
method: "PUT",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<string>",
  "vectorWeights": {},
  "properties": {},
  "id": "<uuid>",
  "creationTimeUnix": "<long>",
  "lastUpdateTimeUnix": "<long>",
  "vector": [
    "<float>",
    "<float>"
  ],
  "vectors": {
    "sint_b38": [
      "<float>",
      "<float>"
    ]
  },
  "tenant": "<string>",
  "additional": {
    "enim9": {},
    "sunt_6a": {},
    "voluptate_e": {}
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:id?consistency_level=QUORUM",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":id"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
}
],
variable: [
{
key: "id",
value: "<uuid>",
description: "(Required) Unique ID of the Object."
}
]
},
description: "Updates an object based on its UUID. Given meta-data and schema values are validated. LastUpdateTime is set to the time this function is called."
},
response: [
{
name: "Successfully received.",
originalRequest: {
method: "PUT",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<string>",
  "vectorWeights": {},
  "properties": {},
  "id": "<uuid>",
  "creationTimeUnix": "<long>",
  "lastUpdateTimeUnix": "<long>",
  "vector": [
    "<float>",
    "<float>"
  ],
  "vectors": {
    "sint_b38": [
      "<float>",
      "<float>"
    ]
  },
  "tenant": "<string>",
  "additional": {
    "enim9": {},
    "sunt_6a": {},
    "voluptate_e": {}
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:id?consistency_level=QUORUM",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":id"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
}
],
variable: [
{
key: "id"
}
]
}
},
status: "OK",
code: 200,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "class": "<string>",
  "vectorWeights": {},
  "properties": {},
  "id": "<uuid>",
  "creationTimeUnix": "<long>",
  "lastUpdateTimeUnix": "<long>",
  "vector": [
    "<float>",
    "<float>"
  ],
  "vectors": {
    "sint_b38": [
      "<float>",
      "<float>"
    ]
  },
  "tenant": "<string>",
  "additional": {
    "enim9": {},
    "sunt_6a": {},
    "voluptate_e": {}
  }
}"
},
{
name: "Unauthorized or invalid credentials.",
originalRequest: {
method: "PUT",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<string>",
  "vectorWeights": {},
  "properties": {},
  "id": "<uuid>",
  "creationTimeUnix": "<long>",
  "lastUpdateTimeUnix": "<long>",
  "vector": [
    "<float>",
    "<float>"
  ],
  "vectors": {
    "sint_b38": [
      "<float>",
      "<float>"
    ]
  },
  "tenant": "<string>",
  "additional": {
    "enim9": {},
    "sunt_6a": {},
    "voluptate_e": {}
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:id?consistency_level=QUORUM",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":id"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
}
],
variable: [
{
key: "id"
}
]
}
},
status: "Unauthorized",
code: 401,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Forbidden",
originalRequest: {
method: "PUT",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<string>",
  "vectorWeights": {},
  "properties": {},
  "id": "<uuid>",
  "creationTimeUnix": "<long>",
  "lastUpdateTimeUnix": "<long>",
  "vector": [
    "<float>",
    "<float>"
  ],
  "vectors": {
    "sint_b38": [
      "<float>",
      "<float>"
    ]
  },
  "tenant": "<string>",
  "additional": {
    "enim9": {},
    "sunt_6a": {},
    "voluptate_e": {}
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:id?consistency_level=QUORUM",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":id"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
}
],
variable: [
{
key: "id"
}
]
}
},
status: "Forbidden",
code: 403,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Successful query result but no resource was found.",
originalRequest: {
method: "PUT",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<string>",
  "vectorWeights": {},
  "properties": {},
  "id": "<uuid>",
  "creationTimeUnix": "<long>",
  "lastUpdateTimeUnix": "<long>",
  "vector": [
    "<float>",
    "<float>"
  ],
  "vectors": {
    "sint_b38": [
      "<float>",
      "<float>"
    ]
  },
  "tenant": "<string>",
  "additional": {
    "enim9": {},
    "sunt_6a": {},
    "voluptate_e": {}
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:id?consistency_level=QUORUM",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":id"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
}
],
variable: [
{
key: "id"
}
]
}
},
status: "Not Found",
code: 404,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Request body is well-formed (i.e., syntactically correct), but semantically erroneous. Are you sure the class is defined in the configuration file?",
originalRequest: {
method: "PUT",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<string>",
  "vectorWeights": {},
  "properties": {},
  "id": "<uuid>",
  "creationTimeUnix": "<long>",
  "lastUpdateTimeUnix": "<long>",
  "vector": [
    "<float>",
    "<float>"
  ],
  "vectors": {
    "sint_b38": [
      "<float>",
      "<float>"
    ]
  },
  "tenant": "<string>",
  "additional": {
    "enim9": {},
    "sunt_6a": {},
    "voluptate_e": {}
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:id?consistency_level=QUORUM",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":id"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
}
],
variable: [
{
key: "id"
}
]
}
},
status: "Unprocessable Entity (WebDAV) (RFC 4918)",
code: 422,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error.",
originalRequest: {
method: "PUT",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<string>",
  "vectorWeights": {},
  "properties": {},
  "id": "<uuid>",
  "creationTimeUnix": "<long>",
  "lastUpdateTimeUnix": "<long>",
  "vector": [
    "<float>",
    "<float>"
  ],
  "vectors": {
    "sint_b38": [
      "<float>",
      "<float>"
    ]
  },
  "tenant": "<string>",
  "additional": {
    "enim9": {},
    "sunt_6a": {},
    "voluptate_e": {}
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:id?consistency_level=QUORUM",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":id"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
}
],
variable: [
{
key: "id"
}
]
}
},
status: "Internal Server Error",
code: 500,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
}
]
},
{
name: "Check if object exists.",
request: {
method: "HEAD",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/objects/:id",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":id"
],
variable: [
{
key: "id",
value: "<uuid>",
description: "(Required) Unique ID of the Object."
}
]
},
description: "Checks if an object exists in the system based on its UUID."
},
response: [
{
name: "Object exists.",
originalRequest: {
method: "HEAD",
header: [ ],
url: {
raw: "{{baseUrl}}/objects/:id",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":id"
],
variable: [
{
key: "id"
}
]
}
},
status: "No Content",
code: 204,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Unauthorized or invalid credentials.",
originalRequest: {
method: "HEAD",
header: [ ],
url: {
raw: "{{baseUrl}}/objects/:id",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":id"
],
variable: [
{
key: "id"
}
]
}
},
status: "Unauthorized",
code: 401,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Forbidden",
originalRequest: {
method: "HEAD",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/objects/:id",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":id"
],
variable: [
{
key: "id"
}
]
}
},
status: "Forbidden",
code: 403,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Object doesn't exist.",
originalRequest: {
method: "HEAD",
header: [ ],
url: {
raw: "{{baseUrl}}/objects/:id",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":id"
],
variable: [
{
key: "id"
}
]
}
},
status: "Not Found",
code: 404,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error.",
originalRequest: {
method: "HEAD",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/objects/:id",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":id"
],
variable: [
{
key: "id"
}
]
}
},
status: "Internal Server Error",
code: 500,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
}
]
}
]
},
{
name: "{className}",
item: [
{
name: "{id}",
item: [
{
name: "references",
item: [
{
name: "{propertyName}",
item: [
{
name: "Add a cross-reference.",
request: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<uri>",
  "schema": {},
  "beacon": "<uri>",
  "href": "<uri>",
  "classification": {
    "overallCount": "<number>",
    "winningCount": "<number>",
    "losingCount": "<number>",
    "closestOverallDistance": "<number>",
    "winningDistance": "<number>",
    "meanWinningDistance": "<number>",
    "closestWinningDistance": "<number>",
    "closestLosingDistance": "<number>",
    "losingDistance": "<number>",
    "meanLosingDistance": "<number>"
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:className/:id/references/:propertyName?consistency_level=QUORUM&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id",
"references",
":propertyName"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "className",
value: "<string>",
description: "(Required) The class name as defined in the schema"
},
{
key: "id",
value: "<uuid>",
description: "(Required) Unique ID of the Object."
},
{
key: "propertyName",
value: "<string>",
description: "(Required) Unique name of the property related to the Object."
}
]
},
description: "Add a single reference to an object. This adds a reference to the array of cross-references of the given property in the source object specified by its collection name and id"
},
response: [
{
name: "Successfully added the reference.",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<uri>",
  "schema": {},
  "beacon": "<uri>",
  "href": "<uri>",
  "classification": {
    "overallCount": "<number>",
    "winningCount": "<number>",
    "losingCount": "<number>",
    "closestOverallDistance": "<number>",
    "winningDistance": "<number>",
    "meanWinningDistance": "<number>",
    "closestWinningDistance": "<number>",
    "closestLosingDistance": "<number>",
    "losingDistance": "<number>",
    "meanLosingDistance": "<number>"
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:className/:id/references/:propertyName?consistency_level=QUORUM&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id",
"references",
":propertyName"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "className"
},
{
key: "id"
},
{
key: "propertyName"
}
]
}
},
status: "OK",
code: 200,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Malformed request.",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<uri>",
  "schema": {},
  "beacon": "<uri>",
  "href": "<uri>",
  "classification": {
    "overallCount": "<number>",
    "winningCount": "<number>",
    "losingCount": "<number>",
    "closestOverallDistance": "<number>",
    "winningDistance": "<number>",
    "meanWinningDistance": "<number>",
    "closestWinningDistance": "<number>",
    "closestLosingDistance": "<number>",
    "losingDistance": "<number>",
    "meanLosingDistance": "<number>"
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:className/:id/references/:propertyName?consistency_level=QUORUM&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id",
"references",
":propertyName"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "className"
},
{
key: "id"
},
{
key: "propertyName"
}
]
}
},
status: "Bad Request",
code: 400,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Unauthorized or invalid credentials.",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<uri>",
  "schema": {},
  "beacon": "<uri>",
  "href": "<uri>",
  "classification": {
    "overallCount": "<number>",
    "winningCount": "<number>",
    "losingCount": "<number>",
    "closestOverallDistance": "<number>",
    "winningDistance": "<number>",
    "meanWinningDistance": "<number>",
    "closestWinningDistance": "<number>",
    "closestLosingDistance": "<number>",
    "losingDistance": "<number>",
    "meanLosingDistance": "<number>"
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:className/:id/references/:propertyName?consistency_level=QUORUM&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id",
"references",
":propertyName"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "className"
},
{
key: "id"
},
{
key: "propertyName"
}
]
}
},
status: "Unauthorized",
code: 401,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Forbidden",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<uri>",
  "schema": {},
  "beacon": "<uri>",
  "href": "<uri>",
  "classification": {
    "overallCount": "<number>",
    "winningCount": "<number>",
    "losingCount": "<number>",
    "closestOverallDistance": "<number>",
    "winningDistance": "<number>",
    "meanWinningDistance": "<number>",
    "closestWinningDistance": "<number>",
    "closestLosingDistance": "<number>",
    "losingDistance": "<number>",
    "meanLosingDistance": "<number>"
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:className/:id/references/:propertyName?consistency_level=QUORUM&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id",
"references",
":propertyName"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "className"
},
{
key: "id"
},
{
key: "propertyName"
}
]
}
},
status: "Forbidden",
code: 403,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Source object doesn't exist.",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<uri>",
  "schema": {},
  "beacon": "<uri>",
  "href": "<uri>",
  "classification": {
    "overallCount": "<number>",
    "winningCount": "<number>",
    "losingCount": "<number>",
    "closestOverallDistance": "<number>",
    "winningDistance": "<number>",
    "meanWinningDistance": "<number>",
    "closestWinningDistance": "<number>",
    "closestLosingDistance": "<number>",
    "losingDistance": "<number>",
    "meanLosingDistance": "<number>"
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:className/:id/references/:propertyName?consistency_level=QUORUM&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id",
"references",
":propertyName"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "className"
},
{
key: "id"
},
{
key: "propertyName"
}
]
}
},
status: "Not Found",
code: 404,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Request body is well-formed (i.e., syntactically correct), but semantically erroneous. Are you sure the property exists or that it is a class?",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<uri>",
  "schema": {},
  "beacon": "<uri>",
  "href": "<uri>",
  "classification": {
    "overallCount": "<number>",
    "winningCount": "<number>",
    "losingCount": "<number>",
    "closestOverallDistance": "<number>",
    "winningDistance": "<number>",
    "meanWinningDistance": "<number>",
    "closestWinningDistance": "<number>",
    "closestLosingDistance": "<number>",
    "losingDistance": "<number>",
    "meanLosingDistance": "<number>"
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:className/:id/references/:propertyName?consistency_level=QUORUM&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id",
"references",
":propertyName"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "className"
},
{
key: "id"
},
{
key: "propertyName"
}
]
}
},
status: "Unprocessable Entity (WebDAV) (RFC 4918)",
code: 422,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error.",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<uri>",
  "schema": {},
  "beacon": "<uri>",
  "href": "<uri>",
  "classification": {
    "overallCount": "<number>",
    "winningCount": "<number>",
    "losingCount": "<number>",
    "closestOverallDistance": "<number>",
    "winningDistance": "<number>",
    "meanWinningDistance": "<number>",
    "closestWinningDistance": "<number>",
    "closestLosingDistance": "<number>",
    "losingDistance": "<number>",
    "meanLosingDistance": "<number>"
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:className/:id/references/:propertyName?consistency_level=QUORUM&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id",
"references",
":propertyName"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "className"
},
{
key: "id"
},
{
key: "propertyName"
}
]
}
},
status: "Internal Server Error",
code: 500,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
}
]
},
{
name: "Replace cross-references.",
request: {
method: "PUT",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "[
  {
    "class": "<uri>",
    "schema": {},
    "beacon": "<uri>",
    "href": "<uri>",
    "classification": {
      "overallCount": "<number>",
      "winningCount": "<number>",
      "losingCount": "<number>",
      "closestOverallDistance": "<number>",
      "winningDistance": "<number>",
      "meanWinningDistance": "<number>",
      "closestWinningDistance": "<number>",
      "closestLosingDistance": "<number>",
      "losingDistance": "<number>",
      "meanLosingDistance": "<number>"
    }
  },
  {
    "class": "<uri>",
    "schema": {},
    "beacon": "<uri>",
    "href": "<uri>",
    "classification": {
      "overallCount": "<number>",
      "winningCount": "<number>",
      "losingCount": "<number>",
      "closestOverallDistance": "<number>",
      "winningDistance": "<number>",
      "meanWinningDistance": "<number>",
      "closestWinningDistance": "<number>",
      "closestLosingDistance": "<number>",
      "losingDistance": "<number>",
      "meanLosingDistance": "<number>"
    }
  }
]",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:className/:id/references/:propertyName?consistency_level=QUORUM&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id",
"references",
":propertyName"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "className",
value: "<string>",
description: "(Required) The class name as defined in the schema"
},
{
key: "id",
value: "<uuid>",
description: "(Required) Unique ID of the Object."
},
{
key: "propertyName",
value: "<string>",
description: "(Required) Unique name of the property related to the Object."
}
]
},
description: "Replace **all** references in cross-reference property of an object."
},
response: [
{
name: "Successfully replaced all the references.",
originalRequest: {
method: "PUT",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "[
  {
    "class": "<uri>",
    "schema": {},
    "beacon": "<uri>",
    "href": "<uri>",
    "classification": {
      "overallCount": "<number>",
      "winningCount": "<number>",
      "losingCount": "<number>",
      "closestOverallDistance": "<number>",
      "winningDistance": "<number>",
      "meanWinningDistance": "<number>",
      "closestWinningDistance": "<number>",
      "closestLosingDistance": "<number>",
      "losingDistance": "<number>",
      "meanLosingDistance": "<number>"
    }
  },
  {
    "class": "<uri>",
    "schema": {},
    "beacon": "<uri>",
    "href": "<uri>",
    "classification": {
      "overallCount": "<number>",
      "winningCount": "<number>",
      "losingCount": "<number>",
      "closestOverallDistance": "<number>",
      "winningDistance": "<number>",
      "meanWinningDistance": "<number>",
      "closestWinningDistance": "<number>",
      "closestLosingDistance": "<number>",
      "losingDistance": "<number>",
      "meanLosingDistance": "<number>"
    }
  }
]",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:className/:id/references/:propertyName?consistency_level=QUORUM&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id",
"references",
":propertyName"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "className"
},
{
key: "id"
},
{
key: "propertyName"
}
]
}
},
status: "OK",
code: 200,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Malformed request.",
originalRequest: {
method: "PUT",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "[
  {
    "class": "<uri>",
    "schema": {},
    "beacon": "<uri>",
    "href": "<uri>",
    "classification": {
      "overallCount": "<number>",
      "winningCount": "<number>",
      "losingCount": "<number>",
      "closestOverallDistance": "<number>",
      "winningDistance": "<number>",
      "meanWinningDistance": "<number>",
      "closestWinningDistance": "<number>",
      "closestLosingDistance": "<number>",
      "losingDistance": "<number>",
      "meanLosingDistance": "<number>"
    }
  },
  {
    "class": "<uri>",
    "schema": {},
    "beacon": "<uri>",
    "href": "<uri>",
    "classification": {
      "overallCount": "<number>",
      "winningCount": "<number>",
      "losingCount": "<number>",
      "closestOverallDistance": "<number>",
      "winningDistance": "<number>",
      "meanWinningDistance": "<number>",
      "closestWinningDistance": "<number>",
      "closestLosingDistance": "<number>",
      "losingDistance": "<number>",
      "meanLosingDistance": "<number>"
    }
  }
]",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:className/:id/references/:propertyName?consistency_level=QUORUM&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id",
"references",
":propertyName"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "className"
},
{
key: "id"
},
{
key: "propertyName"
}
]
}
},
status: "Bad Request",
code: 400,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Unauthorized or invalid credentials.",
originalRequest: {
method: "PUT",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "[
  {
    "class": "<uri>",
    "schema": {},
    "beacon": "<uri>",
    "href": "<uri>",
    "classification": {
      "overallCount": "<number>",
      "winningCount": "<number>",
      "losingCount": "<number>",
      "closestOverallDistance": "<number>",
      "winningDistance": "<number>",
      "meanWinningDistance": "<number>",
      "closestWinningDistance": "<number>",
      "closestLosingDistance": "<number>",
      "losingDistance": "<number>",
      "meanLosingDistance": "<number>"
    }
  },
  {
    "class": "<uri>",
    "schema": {},
    "beacon": "<uri>",
    "href": "<uri>",
    "classification": {
      "overallCount": "<number>",
      "winningCount": "<number>",
      "losingCount": "<number>",
      "closestOverallDistance": "<number>",
      "winningDistance": "<number>",
      "meanWinningDistance": "<number>",
      "closestWinningDistance": "<number>",
      "closestLosingDistance": "<number>",
      "losingDistance": "<number>",
      "meanLosingDistance": "<number>"
    }
  }
]",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:className/:id/references/:propertyName?consistency_level=QUORUM&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id",
"references",
":propertyName"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "className"
},
{
key: "id"
},
{
key: "propertyName"
}
]
}
},
status: "Unauthorized",
code: 401,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Forbidden",
originalRequest: {
method: "PUT",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "[
  {
    "class": "<uri>",
    "schema": {},
    "beacon": "<uri>",
    "href": "<uri>",
    "classification": {
      "overallCount": "<number>",
      "winningCount": "<number>",
      "losingCount": "<number>",
      "closestOverallDistance": "<number>",
      "winningDistance": "<number>",
      "meanWinningDistance": "<number>",
      "closestWinningDistance": "<number>",
      "closestLosingDistance": "<number>",
      "losingDistance": "<number>",
      "meanLosingDistance": "<number>"
    }
  },
  {
    "class": "<uri>",
    "schema": {},
    "beacon": "<uri>",
    "href": "<uri>",
    "classification": {
      "overallCount": "<number>",
      "winningCount": "<number>",
      "losingCount": "<number>",
      "closestOverallDistance": "<number>",
      "winningDistance": "<number>",
      "meanWinningDistance": "<number>",
      "closestWinningDistance": "<number>",
      "closestLosingDistance": "<number>",
      "losingDistance": "<number>",
      "meanLosingDistance": "<number>"
    }
  }
]",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:className/:id/references/:propertyName?consistency_level=QUORUM&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id",
"references",
":propertyName"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "className"
},
{
key: "id"
},
{
key: "propertyName"
}
]
}
},
status: "Forbidden",
code: 403,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Source object doesn't exist.",
originalRequest: {
method: "PUT",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "[
  {
    "class": "<uri>",
    "schema": {},
    "beacon": "<uri>",
    "href": "<uri>",
    "classification": {
      "overallCount": "<number>",
      "winningCount": "<number>",
      "losingCount": "<number>",
      "closestOverallDistance": "<number>",
      "winningDistance": "<number>",
      "meanWinningDistance": "<number>",
      "closestWinningDistance": "<number>",
      "closestLosingDistance": "<number>",
      "losingDistance": "<number>",
      "meanLosingDistance": "<number>"
    }
  },
  {
    "class": "<uri>",
    "schema": {},
    "beacon": "<uri>",
    "href": "<uri>",
    "classification": {
      "overallCount": "<number>",
      "winningCount": "<number>",
      "losingCount": "<number>",
      "closestOverallDistance": "<number>",
      "winningDistance": "<number>",
      "meanWinningDistance": "<number>",
      "closestWinningDistance": "<number>",
      "closestLosingDistance": "<number>",
      "losingDistance": "<number>",
      "meanLosingDistance": "<number>"
    }
  }
]",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:className/:id/references/:propertyName?consistency_level=QUORUM&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id",
"references",
":propertyName"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "className"
},
{
key: "id"
},
{
key: "propertyName"
}
]
}
},
status: "Not Found",
code: 404,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Request body is well-formed (i.e., syntactically correct), but semantically erroneous. Are you sure the property exists or that it is a class?",
originalRequest: {
method: "PUT",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "[
  {
    "class": "<uri>",
    "schema": {},
    "beacon": "<uri>",
    "href": "<uri>",
    "classification": {
      "overallCount": "<number>",
      "winningCount": "<number>",
      "losingCount": "<number>",
      "closestOverallDistance": "<number>",
      "winningDistance": "<number>",
      "meanWinningDistance": "<number>",
      "closestWinningDistance": "<number>",
      "closestLosingDistance": "<number>",
      "losingDistance": "<number>",
      "meanLosingDistance": "<number>"
    }
  },
  {
    "class": "<uri>",
    "schema": {},
    "beacon": "<uri>",
    "href": "<uri>",
    "classification": {
      "overallCount": "<number>",
      "winningCount": "<number>",
      "losingCount": "<number>",
      "closestOverallDistance": "<number>",
      "winningDistance": "<number>",
      "meanWinningDistance": "<number>",
      "closestWinningDistance": "<number>",
      "closestLosingDistance": "<number>",
      "losingDistance": "<number>",
      "meanLosingDistance": "<number>"
    }
  }
]",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:className/:id/references/:propertyName?consistency_level=QUORUM&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id",
"references",
":propertyName"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "className"
},
{
key: "id"
},
{
key: "propertyName"
}
]
}
},
status: "Unprocessable Entity (WebDAV) (RFC 4918)",
code: 422,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error.",
originalRequest: {
method: "PUT",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "[
  {
    "class": "<uri>",
    "schema": {},
    "beacon": "<uri>",
    "href": "<uri>",
    "classification": {
      "overallCount": "<number>",
      "winningCount": "<number>",
      "losingCount": "<number>",
      "closestOverallDistance": "<number>",
      "winningDistance": "<number>",
      "meanWinningDistance": "<number>",
      "closestWinningDistance": "<number>",
      "closestLosingDistance": "<number>",
      "losingDistance": "<number>",
      "meanLosingDistance": "<number>"
    }
  },
  {
    "class": "<uri>",
    "schema": {},
    "beacon": "<uri>",
    "href": "<uri>",
    "classification": {
      "overallCount": "<number>",
      "winningCount": "<number>",
      "losingCount": "<number>",
      "closestOverallDistance": "<number>",
      "winningDistance": "<number>",
      "meanWinningDistance": "<number>",
      "closestWinningDistance": "<number>",
      "closestLosingDistance": "<number>",
      "losingDistance": "<number>",
      "meanLosingDistance": "<number>"
    }
  }
]",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:className/:id/references/:propertyName?consistency_level=QUORUM&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id",
"references",
":propertyName"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "className"
},
{
key: "id"
},
{
key: "propertyName"
}
]
}
},
status: "Internal Server Error",
code: 500,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
}
]
},
{
name: "Delete a cross-reference.",
request: {
method: "DELETE",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<uri>",
  "schema": {},
  "beacon": "<uri>",
  "href": "<uri>",
  "classification": {
    "overallCount": "<number>",
    "winningCount": "<number>",
    "losingCount": "<number>",
    "closestOverallDistance": "<number>",
    "winningDistance": "<number>",
    "meanWinningDistance": "<number>",
    "closestWinningDistance": "<number>",
    "closestLosingDistance": "<number>",
    "losingDistance": "<number>",
    "meanLosingDistance": "<number>"
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:className/:id/references/:propertyName?consistency_level=QUORUM&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id",
"references",
":propertyName"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "className",
value: "<string>",
description: "(Required) The class name as defined in the schema"
},
{
key: "id",
value: "<uuid>",
description: "(Required) Unique ID of the Object."
},
{
key: "propertyName",
value: "<string>",
description: "(Required) Unique name of the property related to the Object."
}
]
},
description: "Delete the single reference that is given in the body from the list of references that this property has."
},
response: [
{
name: "Successfully deleted.",
originalRequest: {
method: "DELETE",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<uri>",
  "schema": {},
  "beacon": "<uri>",
  "href": "<uri>",
  "classification": {
    "overallCount": "<number>",
    "winningCount": "<number>",
    "losingCount": "<number>",
    "closestOverallDistance": "<number>",
    "winningDistance": "<number>",
    "meanWinningDistance": "<number>",
    "closestWinningDistance": "<number>",
    "closestLosingDistance": "<number>",
    "losingDistance": "<number>",
    "meanLosingDistance": "<number>"
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:className/:id/references/:propertyName?consistency_level=QUORUM&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id",
"references",
":propertyName"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "className"
},
{
key: "id"
},
{
key: "propertyName"
}
]
}
},
status: "No Content",
code: 204,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Malformed request.",
originalRequest: {
method: "DELETE",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<uri>",
  "schema": {},
  "beacon": "<uri>",
  "href": "<uri>",
  "classification": {
    "overallCount": "<number>",
    "winningCount": "<number>",
    "losingCount": "<number>",
    "closestOverallDistance": "<number>",
    "winningDistance": "<number>",
    "meanWinningDistance": "<number>",
    "closestWinningDistance": "<number>",
    "closestLosingDistance": "<number>",
    "losingDistance": "<number>",
    "meanLosingDistance": "<number>"
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:className/:id/references/:propertyName?consistency_level=QUORUM&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id",
"references",
":propertyName"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "className"
},
{
key: "id"
},
{
key: "propertyName"
}
]
}
},
status: "Bad Request",
code: 400,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Unauthorized or invalid credentials.",
originalRequest: {
method: "DELETE",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<uri>",
  "schema": {},
  "beacon": "<uri>",
  "href": "<uri>",
  "classification": {
    "overallCount": "<number>",
    "winningCount": "<number>",
    "losingCount": "<number>",
    "closestOverallDistance": "<number>",
    "winningDistance": "<number>",
    "meanWinningDistance": "<number>",
    "closestWinningDistance": "<number>",
    "closestLosingDistance": "<number>",
    "losingDistance": "<number>",
    "meanLosingDistance": "<number>"
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:className/:id/references/:propertyName?consistency_level=QUORUM&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id",
"references",
":propertyName"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "className"
},
{
key: "id"
},
{
key: "propertyName"
}
]
}
},
status: "Unauthorized",
code: 401,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Forbidden",
originalRequest: {
method: "DELETE",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<uri>",
  "schema": {},
  "beacon": "<uri>",
  "href": "<uri>",
  "classification": {
    "overallCount": "<number>",
    "winningCount": "<number>",
    "losingCount": "<number>",
    "closestOverallDistance": "<number>",
    "winningDistance": "<number>",
    "meanWinningDistance": "<number>",
    "closestWinningDistance": "<number>",
    "closestLosingDistance": "<number>",
    "losingDistance": "<number>",
    "meanLosingDistance": "<number>"
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:className/:id/references/:propertyName?consistency_level=QUORUM&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id",
"references",
":propertyName"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "className"
},
{
key: "id"
},
{
key: "propertyName"
}
]
}
},
status: "Forbidden",
code: 403,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Successful query result but no resource was found.",
originalRequest: {
method: "DELETE",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<uri>",
  "schema": {},
  "beacon": "<uri>",
  "href": "<uri>",
  "classification": {
    "overallCount": "<number>",
    "winningCount": "<number>",
    "losingCount": "<number>",
    "closestOverallDistance": "<number>",
    "winningDistance": "<number>",
    "meanWinningDistance": "<number>",
    "closestWinningDistance": "<number>",
    "closestLosingDistance": "<number>",
    "losingDistance": "<number>",
    "meanLosingDistance": "<number>"
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:className/:id/references/:propertyName?consistency_level=QUORUM&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id",
"references",
":propertyName"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "className"
},
{
key: "id"
},
{
key: "propertyName"
}
]
}
},
status: "Not Found",
code: 404,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Request body is well-formed (i.e., syntactically correct), but semantically erroneous. Are you sure the property exists or that it is a class?",
originalRequest: {
method: "DELETE",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<uri>",
  "schema": {},
  "beacon": "<uri>",
  "href": "<uri>",
  "classification": {
    "overallCount": "<number>",
    "winningCount": "<number>",
    "losingCount": "<number>",
    "closestOverallDistance": "<number>",
    "winningDistance": "<number>",
    "meanWinningDistance": "<number>",
    "closestWinningDistance": "<number>",
    "closestLosingDistance": "<number>",
    "losingDistance": "<number>",
    "meanLosingDistance": "<number>"
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:className/:id/references/:propertyName?consistency_level=QUORUM&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id",
"references",
":propertyName"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "className"
},
{
key: "id"
},
{
key: "propertyName"
}
]
}
},
status: "Unprocessable Entity (WebDAV) (RFC 4918)",
code: 422,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error.",
originalRequest: {
method: "DELETE",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<uri>",
  "schema": {},
  "beacon": "<uri>",
  "href": "<uri>",
  "classification": {
    "overallCount": "<number>",
    "winningCount": "<number>",
    "losingCount": "<number>",
    "closestOverallDistance": "<number>",
    "winningDistance": "<number>",
    "meanWinningDistance": "<number>",
    "closestWinningDistance": "<number>",
    "closestLosingDistance": "<number>",
    "losingDistance": "<number>",
    "meanLosingDistance": "<number>"
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:className/:id/references/:propertyName?consistency_level=QUORUM&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id",
"references",
":propertyName"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "className"
},
{
key: "id"
},
{
key: "propertyName"
}
]
}
},
status: "Internal Server Error",
code: 500,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
}
]
}
]
}
]
},
{
name: "Get an object.",
request: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/objects/:className/:id?include=<string>&consistency_level=QUORUM&node_name=<string>&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id"
],
query: [
{
key: "include",
value: "<string>",
description: "Include additional information, such as classification infos. Allowed values include: `classification`, `vector`, `interpretation`, `featureProjection` and other module-specific additional properties."
},
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "node_name",
value: "<string>",
description: "The target node which should fulfill the request"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "className",
value: "<string>",
description: "(Required) "
},
{
key: "id",
value: "<uuid>",
description: "(Required) Unique ID of the Object."
}
]
},
description: "Get a data object based on its collection and UUID. Also available as Websocket bus."
},
response: [
{
name: "Successful response.",
originalRequest: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/objects/:className/:id?include=<string>&consistency_level=QUORUM&node_name=<string>&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id"
],
query: [
{
key: "include",
value: "<string>",
description: "Include additional information, such as classification infos. Allowed values include: `classification`, `vector`, `interpretation`, `featureProjection` and other module-specific additional properties."
},
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "node_name",
value: "<string>",
description: "The target node which should fulfill the request"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "className"
},
{
key: "id"
}
]
}
},
status: "OK",
code: 200,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "class": "<string>",
  "vectorWeights": {},
  "properties": {},
  "id": "<uuid>",
  "creationTimeUnix": "<long>",
  "lastUpdateTimeUnix": "<long>",
  "vector": [
    "<float>",
    "<float>"
  ],
  "vectors": {
    "sint_b38": [
      "<float>",
      "<float>"
    ]
  },
  "tenant": "<string>",
  "additional": {
    "enim9": {},
    "sunt_6a": {},
    "voluptate_e": {}
  }
}"
},
{
name: "Malformed request.",
originalRequest: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/objects/:className/:id?include=<string>&consistency_level=QUORUM&node_name=<string>&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id"
],
query: [
{
key: "include",
value: "<string>",
description: "Include additional information, such as classification infos. Allowed values include: `classification`, `vector`, `interpretation`, `featureProjection` and other module-specific additional properties."
},
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "node_name",
value: "<string>",
description: "The target node which should fulfill the request"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "className"
},
{
key: "id"
}
]
}
},
status: "Bad Request",
code: 400,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Unauthorized or invalid credentials.",
originalRequest: {
method: "GET",
header: [ ],
url: {
raw: "{{baseUrl}}/objects/:className/:id?include=<string>&consistency_level=QUORUM&node_name=<string>&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id"
],
query: [
{
key: "include",
value: "<string>",
description: "Include additional information, such as classification infos. Allowed values include: `classification`, `vector`, `interpretation`, `featureProjection` and other module-specific additional properties."
},
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "node_name",
value: "<string>",
description: "The target node which should fulfill the request"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "className"
},
{
key: "id"
}
]
}
},
status: "Unauthorized",
code: 401,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Forbidden",
originalRequest: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/objects/:className/:id?include=<string>&consistency_level=QUORUM&node_name=<string>&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id"
],
query: [
{
key: "include",
value: "<string>",
description: "Include additional information, such as classification infos. Allowed values include: `classification`, `vector`, `interpretation`, `featureProjection` and other module-specific additional properties."
},
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "node_name",
value: "<string>",
description: "The target node which should fulfill the request"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "className"
},
{
key: "id"
}
]
}
},
status: "Forbidden",
code: 403,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Successful query result but no resource was found.",
originalRequest: {
method: "GET",
header: [ ],
url: {
raw: "{{baseUrl}}/objects/:className/:id?include=<string>&consistency_level=QUORUM&node_name=<string>&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id"
],
query: [
{
key: "include",
value: "<string>",
description: "Include additional information, such as classification infos. Allowed values include: `classification`, `vector`, `interpretation`, `featureProjection` and other module-specific additional properties."
},
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "node_name",
value: "<string>",
description: "The target node which should fulfill the request"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "className"
},
{
key: "id"
}
]
}
},
status: "Not Found",
code: 404,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Request is well-formed (i.e., syntactically correct), but erroneous.",
originalRequest: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/objects/:className/:id?include=<string>&consistency_level=QUORUM&node_name=<string>&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id"
],
query: [
{
key: "include",
value: "<string>",
description: "Include additional information, such as classification infos. Allowed values include: `classification`, `vector`, `interpretation`, `featureProjection` and other module-specific additional properties."
},
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "node_name",
value: "<string>",
description: "The target node which should fulfill the request"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "className"
},
{
key: "id"
}
]
}
},
status: "Unprocessable Entity (WebDAV) (RFC 4918)",
code: 422,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error.",
originalRequest: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/objects/:className/:id?include=<string>&consistency_level=QUORUM&node_name=<string>&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id"
],
query: [
{
key: "include",
value: "<string>",
description: "Include additional information, such as classification infos. Allowed values include: `classification`, `vector`, `interpretation`, `featureProjection` and other module-specific additional properties."
},
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "node_name",
value: "<string>",
description: "The target node which should fulfill the request"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "className"
},
{
key: "id"
}
]
}
},
status: "Internal Server Error",
code: 500,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
}
]
},
{
name: "Delete an object.",
request: {
method: "DELETE",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/objects/:className/:id?consistency_level=QUORUM&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "className",
value: "<string>",
description: "(Required) "
},
{
key: "id",
value: "<uuid>",
description: "(Required) Unique ID of the Object."
}
]
},
description: "Delete an object based on its collection and UUID. <br/><br/>Note: For backward compatibility, beacons also support an older, deprecated format without the collection name. As a result, when deleting a reference, the beacon specified has to match the beacon to be deleted exactly. In other words, if a beacon is present using the old format (without collection name) you also need to specify it the same way. <br/><br/>In the beacon format, you need to always use `localhost` as the host, rather than the actual hostname. `localhost` here refers to the fact that the beacon's target is on the same Weaviate instance, as opposed to a foreign instance."
},
response: [
{
name: "Successfully deleted.",
originalRequest: {
method: "DELETE",
header: [ ],
url: {
raw: "{{baseUrl}}/objects/:className/:id?consistency_level=QUORUM&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "className"
},
{
key: "id"
}
]
}
},
status: "No Content",
code: 204,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Malformed request.",
originalRequest: {
method: "DELETE",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/objects/:className/:id?consistency_level=QUORUM&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "className"
},
{
key: "id"
}
]
}
},
status: "Bad Request",
code: 400,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Unauthorized or invalid credentials.",
originalRequest: {
method: "DELETE",
header: [ ],
url: {
raw: "{{baseUrl}}/objects/:className/:id?consistency_level=QUORUM&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "className"
},
{
key: "id"
}
]
}
},
status: "Unauthorized",
code: 401,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Forbidden",
originalRequest: {
method: "DELETE",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/objects/:className/:id?consistency_level=QUORUM&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "className"
},
{
key: "id"
}
]
}
},
status: "Forbidden",
code: 403,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Successful query result but no resource was found.",
originalRequest: {
method: "DELETE",
header: [ ],
url: {
raw: "{{baseUrl}}/objects/:className/:id?consistency_level=QUORUM&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "className"
},
{
key: "id"
}
]
}
},
status: "Not Found",
code: 404,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Request is well-formed (i.e., syntactically correct), but erroneous.",
originalRequest: {
method: "DELETE",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/objects/:className/:id?consistency_level=QUORUM&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "className"
},
{
key: "id"
}
]
}
},
status: "Unprocessable Entity (WebDAV) (RFC 4918)",
code: 422,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error.",
originalRequest: {
method: "DELETE",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/objects/:className/:id?consistency_level=QUORUM&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "className"
},
{
key: "id"
}
]
}
},
status: "Internal Server Error",
code: 500,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
}
]
},
{
name: "Update an object.",
request: {
method: "PUT",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<string>",
  "vectorWeights": {},
  "properties": {},
  "id": "<uuid>",
  "creationTimeUnix": "<long>",
  "lastUpdateTimeUnix": "<long>",
  "vector": [
    "<float>",
    "<float>"
  ],
  "vectors": {
    "sint_b38": [
      "<float>",
      "<float>"
    ]
  },
  "tenant": "<string>",
  "additional": {
    "enim9": {},
    "sunt_6a": {},
    "voluptate_e": {}
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:className/:id?consistency_level=QUORUM",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
}
],
variable: [
{
key: "className",
value: "<string>",
description: "(Required) "
},
{
key: "id",
value: "<uuid>",
description: "(Required) The uuid of the data object to update."
}
]
},
description: "Update an object based on its uuid and collection. This (`put`) method replaces the object with the provided object."
},
response: [
{
name: "Successfully received.",
originalRequest: {
method: "PUT",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<string>",
  "vectorWeights": {},
  "properties": {},
  "id": "<uuid>",
  "creationTimeUnix": "<long>",
  "lastUpdateTimeUnix": "<long>",
  "vector": [
    "<float>",
    "<float>"
  ],
  "vectors": {
    "sint_b38": [
      "<float>",
      "<float>"
    ]
  },
  "tenant": "<string>",
  "additional": {
    "enim9": {},
    "sunt_6a": {},
    "voluptate_e": {}
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:className/:id?consistency_level=QUORUM",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
}
],
variable: [
{
key: "className"
},
{
key: "id"
}
]
}
},
status: "OK",
code: 200,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "class": "<string>",
  "vectorWeights": {},
  "properties": {},
  "id": "<uuid>",
  "creationTimeUnix": "<long>",
  "lastUpdateTimeUnix": "<long>",
  "vector": [
    "<float>",
    "<float>"
  ],
  "vectors": {
    "sint_b38": [
      "<float>",
      "<float>"
    ]
  },
  "tenant": "<string>",
  "additional": {
    "enim9": {},
    "sunt_6a": {},
    "voluptate_e": {}
  }
}"
},
{
name: "Unauthorized or invalid credentials.",
originalRequest: {
method: "PUT",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<string>",
  "vectorWeights": {},
  "properties": {},
  "id": "<uuid>",
  "creationTimeUnix": "<long>",
  "lastUpdateTimeUnix": "<long>",
  "vector": [
    "<float>",
    "<float>"
  ],
  "vectors": {
    "sint_b38": [
      "<float>",
      "<float>"
    ]
  },
  "tenant": "<string>",
  "additional": {
    "enim9": {},
    "sunt_6a": {},
    "voluptate_e": {}
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:className/:id?consistency_level=QUORUM",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
}
],
variable: [
{
key: "className"
},
{
key: "id"
}
]
}
},
status: "Unauthorized",
code: 401,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Forbidden",
originalRequest: {
method: "PUT",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<string>",
  "vectorWeights": {},
  "properties": {},
  "id": "<uuid>",
  "creationTimeUnix": "<long>",
  "lastUpdateTimeUnix": "<long>",
  "vector": [
    "<float>",
    "<float>"
  ],
  "vectors": {
    "sint_b38": [
      "<float>",
      "<float>"
    ]
  },
  "tenant": "<string>",
  "additional": {
    "enim9": {},
    "sunt_6a": {},
    "voluptate_e": {}
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:className/:id?consistency_level=QUORUM",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
}
],
variable: [
{
key: "className"
},
{
key: "id"
}
]
}
},
status: "Forbidden",
code: 403,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Successful query result but no resource was found.",
originalRequest: {
method: "PUT",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<string>",
  "vectorWeights": {},
  "properties": {},
  "id": "<uuid>",
  "creationTimeUnix": "<long>",
  "lastUpdateTimeUnix": "<long>",
  "vector": [
    "<float>",
    "<float>"
  ],
  "vectors": {
    "sint_b38": [
      "<float>",
      "<float>"
    ]
  },
  "tenant": "<string>",
  "additional": {
    "enim9": {},
    "sunt_6a": {},
    "voluptate_e": {}
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:className/:id?consistency_level=QUORUM",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
}
],
variable: [
{
key: "className"
},
{
key: "id"
}
]
}
},
status: "Not Found",
code: 404,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Request body is well-formed (i.e., syntactically correct), but semantically erroneous. Are you sure the class is defined in the configuration file?",
originalRequest: {
method: "PUT",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<string>",
  "vectorWeights": {},
  "properties": {},
  "id": "<uuid>",
  "creationTimeUnix": "<long>",
  "lastUpdateTimeUnix": "<long>",
  "vector": [
    "<float>",
    "<float>"
  ],
  "vectors": {
    "sint_b38": [
      "<float>",
      "<float>"
    ]
  },
  "tenant": "<string>",
  "additional": {
    "enim9": {},
    "sunt_6a": {},
    "voluptate_e": {}
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:className/:id?consistency_level=QUORUM",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
}
],
variable: [
{
key: "className"
},
{
key: "id"
}
]
}
},
status: "Unprocessable Entity (WebDAV) (RFC 4918)",
code: 422,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error.",
originalRequest: {
method: "PUT",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<string>",
  "vectorWeights": {},
  "properties": {},
  "id": "<uuid>",
  "creationTimeUnix": "<long>",
  "lastUpdateTimeUnix": "<long>",
  "vector": [
    "<float>",
    "<float>"
  ],
  "vectors": {
    "sint_b38": [
      "<float>",
      "<float>"
    ]
  },
  "tenant": "<string>",
  "additional": {
    "enim9": {},
    "sunt_6a": {},
    "voluptate_e": {}
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:className/:id?consistency_level=QUORUM",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
}
],
variable: [
{
key: "className"
},
{
key: "id"
}
]
}
},
status: "Internal Server Error",
code: 500,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
}
]
},
{
name: "Update an object using patch semantics.",
request: {
method: "PATCH",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<string>",
  "vectorWeights": {},
  "properties": {},
  "id": "<uuid>",
  "creationTimeUnix": "<long>",
  "lastUpdateTimeUnix": "<long>",
  "vector": [
    "<float>",
    "<float>"
  ],
  "vectors": {
    "sint_b38": [
      "<float>",
      "<float>"
    ]
  },
  "tenant": "<string>",
  "additional": {
    "enim9": {},
    "sunt_6a": {},
    "voluptate_e": {}
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:className/:id?consistency_level=QUORUM",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
}
],
variable: [
{
key: "className",
value: "<string>",
description: "(Required) The class name as defined in the schema"
},
{
key: "id",
value: "<uuid>",
description: "(Required) The uuid of the data object to update."
}
]
},
description: "Update an individual data object based on its collection and uuid. This method supports json-merge style patch semantics (RFC 7396). Provided meta-data and schema values are validated. LastUpdateTime is set to the time this function is called."
},
response: [
{
name: "Successfully applied. No content provided.",
originalRequest: {
method: "PATCH",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<string>",
  "vectorWeights": {},
  "properties": {},
  "id": "<uuid>",
  "creationTimeUnix": "<long>",
  "lastUpdateTimeUnix": "<long>",
  "vector": [
    "<float>",
    "<float>"
  ],
  "vectors": {
    "sint_b38": [
      "<float>",
      "<float>"
    ]
  },
  "tenant": "<string>",
  "additional": {
    "enim9": {},
    "sunt_6a": {},
    "voluptate_e": {}
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:className/:id?consistency_level=QUORUM",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
}
],
variable: [
{
key: "className"
},
{
key: "id"
}
]
}
},
status: "No Content",
code: 204,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "The patch-JSON is malformed.",
originalRequest: {
method: "PATCH",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<string>",
  "vectorWeights": {},
  "properties": {},
  "id": "<uuid>",
  "creationTimeUnix": "<long>",
  "lastUpdateTimeUnix": "<long>",
  "vector": [
    "<float>",
    "<float>"
  ],
  "vectors": {
    "sint_b38": [
      "<float>",
      "<float>"
    ]
  },
  "tenant": "<string>",
  "additional": {
    "enim9": {},
    "sunt_6a": {},
    "voluptate_e": {}
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:className/:id?consistency_level=QUORUM",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
}
],
variable: [
{
key: "className"
},
{
key: "id"
}
]
}
},
status: "Bad Request",
code: 400,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Unauthorized or invalid credentials.",
originalRequest: {
method: "PATCH",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<string>",
  "vectorWeights": {},
  "properties": {},
  "id": "<uuid>",
  "creationTimeUnix": "<long>",
  "lastUpdateTimeUnix": "<long>",
  "vector": [
    "<float>",
    "<float>"
  ],
  "vectors": {
    "sint_b38": [
      "<float>",
      "<float>"
    ]
  },
  "tenant": "<string>",
  "additional": {
    "enim9": {},
    "sunt_6a": {},
    "voluptate_e": {}
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:className/:id?consistency_level=QUORUM",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
}
],
variable: [
{
key: "className"
},
{
key: "id"
}
]
}
},
status: "Unauthorized",
code: 401,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Forbidden",
originalRequest: {
method: "PATCH",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<string>",
  "vectorWeights": {},
  "properties": {},
  "id": "<uuid>",
  "creationTimeUnix": "<long>",
  "lastUpdateTimeUnix": "<long>",
  "vector": [
    "<float>",
    "<float>"
  ],
  "vectors": {
    "sint_b38": [
      "<float>",
      "<float>"
    ]
  },
  "tenant": "<string>",
  "additional": {
    "enim9": {},
    "sunt_6a": {},
    "voluptate_e": {}
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:className/:id?consistency_level=QUORUM",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
}
],
variable: [
{
key: "className"
},
{
key: "id"
}
]
}
},
status: "Forbidden",
code: 403,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Successful query result but no resource was found.",
originalRequest: {
method: "PATCH",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<string>",
  "vectorWeights": {},
  "properties": {},
  "id": "<uuid>",
  "creationTimeUnix": "<long>",
  "lastUpdateTimeUnix": "<long>",
  "vector": [
    "<float>",
    "<float>"
  ],
  "vectors": {
    "sint_b38": [
      "<float>",
      "<float>"
    ]
  },
  "tenant": "<string>",
  "additional": {
    "enim9": {},
    "sunt_6a": {},
    "voluptate_e": {}
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:className/:id?consistency_level=QUORUM",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
}
],
variable: [
{
key: "className"
},
{
key: "id"
}
]
}
},
status: "Not Found",
code: 404,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "The patch-JSON is valid but unprocessable.",
originalRequest: {
method: "PATCH",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<string>",
  "vectorWeights": {},
  "properties": {},
  "id": "<uuid>",
  "creationTimeUnix": "<long>",
  "lastUpdateTimeUnix": "<long>",
  "vector": [
    "<float>",
    "<float>"
  ],
  "vectors": {
    "sint_b38": [
      "<float>",
      "<float>"
    ]
  },
  "tenant": "<string>",
  "additional": {
    "enim9": {},
    "sunt_6a": {},
    "voluptate_e": {}
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:className/:id?consistency_level=QUORUM",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
}
],
variable: [
{
key: "className"
},
{
key: "id"
}
]
}
},
status: "Unprocessable Entity (WebDAV) (RFC 4918)",
code: 422,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error.",
originalRequest: {
method: "PATCH",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<string>",
  "vectorWeights": {},
  "properties": {},
  "id": "<uuid>",
  "creationTimeUnix": "<long>",
  "lastUpdateTimeUnix": "<long>",
  "vector": [
    "<float>",
    "<float>"
  ],
  "vectors": {
    "sint_b38": [
      "<float>",
      "<float>"
    ]
  },
  "tenant": "<string>",
  "additional": {
    "enim9": {},
    "sunt_6a": {},
    "voluptate_e": {}
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/:className/:id?consistency_level=QUORUM",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
}
],
variable: [
{
key: "className"
},
{
key: "id"
}
]
}
},
status: "Internal Server Error",
code: 500,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
}
]
},
{
name: "Check if an object exists.",
request: {
method: "HEAD",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/objects/:className/:id?consistency_level=QUORUM&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "className",
value: "<string>",
description: "(Required) The class name as defined in the schema"
},
{
key: "id",
value: "<uuid>",
description: "(Required) The uuid of the data object"
}
]
},
description: "Checks if a data object exists based on its collection and uuid without retrieving it. <br/><br/>Internally it skips reading the object from disk other than checking if it is present. Thus it does not use resources on marshalling, parsing, etc., and is faster. Note the resulting HTTP request has no body; the existence of an object is indicated solely by the status code."
},
response: [
{
name: "Object exists.",
originalRequest: {
method: "HEAD",
header: [ ],
url: {
raw: "{{baseUrl}}/objects/:className/:id?consistency_level=QUORUM&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "className"
},
{
key: "id"
}
]
}
},
status: "No Content",
code: 204,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Unauthorized or invalid credentials.",
originalRequest: {
method: "HEAD",
header: [ ],
url: {
raw: "{{baseUrl}}/objects/:className/:id?consistency_level=QUORUM&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "className"
},
{
key: "id"
}
]
}
},
status: "Unauthorized",
code: 401,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Forbidden",
originalRequest: {
method: "HEAD",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/objects/:className/:id?consistency_level=QUORUM&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "className"
},
{
key: "id"
}
]
}
},
status: "Forbidden",
code: 403,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Object doesn't exist.",
originalRequest: {
method: "HEAD",
header: [ ],
url: {
raw: "{{baseUrl}}/objects/:className/:id?consistency_level=QUORUM&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "className"
},
{
key: "id"
}
]
}
},
status: "Not Found",
code: 404,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Request is well-formed (i.e., syntactically correct), but erroneous.",
originalRequest: {
method: "HEAD",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/objects/:className/:id?consistency_level=QUORUM&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "className"
},
{
key: "id"
}
]
}
},
status: "Unprocessable Entity (WebDAV) (RFC 4918)",
code: 422,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error.",
originalRequest: {
method: "HEAD",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/objects/:className/:id?consistency_level=QUORUM&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects",
":className",
":id"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
],
variable: [
{
key: "className"
},
{
key: "id"
}
]
}
},
status: "Internal Server Error",
code: 500,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
}
]
}
]
}
]
},
{
name: "validate",
item: [
{
name: "Validate an object.",
request: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<string>",
  "vectorWeights": {},
  "properties": {},
  "id": "<uuid>",
  "creationTimeUnix": "<long>",
  "lastUpdateTimeUnix": "<long>",
  "vector": [
    "<float>",
    "<float>"
  ],
  "vectors": {
    "sint_b38": [
      "<float>",
      "<float>"
    ]
  },
  "tenant": "<string>",
  "additional": {
    "enim9": {},
    "sunt_6a": {},
    "voluptate_e": {}
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/validate",
host: [
"{{baseUrl}}"
],
path: [
"objects",
"validate"
]
},
description: "Validate an object's schema and meta-data without creating it. <br/><br/>If the schema of the object is valid, the request should return nothing with a plain RESTful request. Otherwise, an error object will be returned."
},
response: [
{
name: "Successfully validated.",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<string>",
  "vectorWeights": {},
  "properties": {},
  "id": "<uuid>",
  "creationTimeUnix": "<long>",
  "lastUpdateTimeUnix": "<long>",
  "vector": [
    "<float>",
    "<float>"
  ],
  "vectors": {
    "sint_b38": [
      "<float>",
      "<float>"
    ]
  },
  "tenant": "<string>",
  "additional": {
    "enim9": {},
    "sunt_6a": {},
    "voluptate_e": {}
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/validate",
host: [
"{{baseUrl}}"
],
path: [
"objects",
"validate"
]
}
},
status: "OK",
code: 200,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Unauthorized or invalid credentials.",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<string>",
  "vectorWeights": {},
  "properties": {},
  "id": "<uuid>",
  "creationTimeUnix": "<long>",
  "lastUpdateTimeUnix": "<long>",
  "vector": [
    "<float>",
    "<float>"
  ],
  "vectors": {
    "sint_b38": [
      "<float>",
      "<float>"
    ]
  },
  "tenant": "<string>",
  "additional": {
    "enim9": {},
    "sunt_6a": {},
    "voluptate_e": {}
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/validate",
host: [
"{{baseUrl}}"
],
path: [
"objects",
"validate"
]
}
},
status: "Unauthorized",
code: 401,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Forbidden",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<string>",
  "vectorWeights": {},
  "properties": {},
  "id": "<uuid>",
  "creationTimeUnix": "<long>",
  "lastUpdateTimeUnix": "<long>",
  "vector": [
    "<float>",
    "<float>"
  ],
  "vectors": {
    "sint_b38": [
      "<float>",
      "<float>"
    ]
  },
  "tenant": "<string>",
  "additional": {
    "enim9": {},
    "sunt_6a": {},
    "voluptate_e": {}
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/validate",
host: [
"{{baseUrl}}"
],
path: [
"objects",
"validate"
]
}
},
status: "Forbidden",
code: 403,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Request body is well-formed (i.e., syntactically correct), but semantically erroneous. Are you sure the class is defined in the configuration file?",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<string>",
  "vectorWeights": {},
  "properties": {},
  "id": "<uuid>",
  "creationTimeUnix": "<long>",
  "lastUpdateTimeUnix": "<long>",
  "vector": [
    "<float>",
    "<float>"
  ],
  "vectors": {
    "sint_b38": [
      "<float>",
      "<float>"
    ]
  },
  "tenant": "<string>",
  "additional": {
    "enim9": {},
    "sunt_6a": {},
    "voluptate_e": {}
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/validate",
host: [
"{{baseUrl}}"
],
path: [
"objects",
"validate"
]
}
},
status: "Unprocessable Entity (WebDAV) (RFC 4918)",
code: 422,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error.",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<string>",
  "vectorWeights": {},
  "properties": {},
  "id": "<uuid>",
  "creationTimeUnix": "<long>",
  "lastUpdateTimeUnix": "<long>",
  "vector": [
    "<float>",
    "<float>"
  ],
  "vectors": {
    "sint_b38": [
      "<float>",
      "<float>"
    ]
  },
  "tenant": "<string>",
  "additional": {
    "enim9": {},
    "sunt_6a": {},
    "voluptate_e": {}
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects/validate",
host: [
"{{baseUrl}}"
],
path: [
"objects",
"validate"
]
}
},
status: "Internal Server Error",
code: 500,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
}
]
}
]
},
{
name: "Get a list of objects.",
request: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/objects?after=<string>&offset=0&limit=25&include=<string>&sort=<string>&order=asc&class=<string>&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects"
],
query: [
{
key: "after",
value: "<string>",
description: "A threshold UUID of the objects to retrieve after, using an UUID-based ordering. This object is not part of the set. <br/><br/>Must be used with `class`, typically in conjunction with `limit`. <br/><br/>Note `after` cannot be used with `offset` or `sort`. <br/><br/>For a null value similar to offset=0, set an empty string in the request, i.e. `after=` or `after`."
},
{
key: "offset",
value: "0",
description: "The starting index of the result window. Note `offset` will retrieve `offset+limit` results and return `limit` results from the object with index `offset` onwards. Limited by the value of `QUERY_MAXIMUM_RESULTS`. <br/><br/>Should be used in conjunction with `limit`. <br/><br/>Cannot be used with `after`."
},
{
key: "limit",
value: "25",
description: "The maximum number of items to be returned per page. The default is 25 unless set otherwise as an environment variable."
},
{
key: "include",
value: "<string>",
description: "Include additional information, such as classification infos. Allowed values include: `classification`, `vector`, `interpretation`, `featureProjection` and other module-specific additional properties."
},
{
key: "sort",
value: "<string>",
description: "Name(s) of the property to sort by - e.g. `city`, or `country,city`."
},
{
key: "order",
value: "asc",
description: "Order parameter to tell how to order (asc or desc) data within given field. Should be used in conjunction with `sort` parameter. If providing multiple `sort` values, provide multiple `order` values in corresponding order, e.g.: `sort=author_name,title&order=desc,asc`."
},
{
key: "class",
value: "<string>",
description: "The collection from which to query objects.  <br/><br/>Note that if `class` is not provided, the response will not include any objects."
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
]
},
description: "Lists all objects in reverse order of creation. The data will be returned as an array of objects. <br/><br/>Tip: If you are looking to list all objects in a collection, use the `after` parameter."
},
response: [
{
name: "Successful response. <br/><br/>If `class` is not provided, the response will not include any objects.",
originalRequest: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/objects?after=<string>&offset=0&limit=25&include=<string>&sort=<string>&order=asc&class=<string>&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects"
],
query: [
{
key: "after",
value: "<string>",
description: "A threshold UUID of the objects to retrieve after, using an UUID-based ordering. This object is not part of the set. <br/><br/>Must be used with `class`, typically in conjunction with `limit`. <br/><br/>Note `after` cannot be used with `offset` or `sort`. <br/><br/>For a null value similar to offset=0, set an empty string in the request, i.e. `after=` or `after`."
},
{
key: "offset",
value: "0",
description: "The starting index of the result window. Note `offset` will retrieve `offset+limit` results and return `limit` results from the object with index `offset` onwards. Limited by the value of `QUERY_MAXIMUM_RESULTS`. <br/><br/>Should be used in conjunction with `limit`. <br/><br/>Cannot be used with `after`."
},
{
key: "limit",
value: "25",
description: "The maximum number of items to be returned per page. The default is 25 unless set otherwise as an environment variable."
},
{
key: "include",
value: "<string>",
description: "Include additional information, such as classification infos. Allowed values include: `classification`, `vector`, `interpretation`, `featureProjection` and other module-specific additional properties."
},
{
key: "sort",
value: "<string>",
description: "Name(s) of the property to sort by - e.g. `city`, or `country,city`."
},
{
key: "order",
value: "asc",
description: "Order parameter to tell how to order (asc or desc) data within given field. Should be used in conjunction with `sort` parameter. If providing multiple `sort` values, provide multiple `order` values in corresponding order, e.g.: `sort=author_name,title&order=desc,asc`."
},
{
key: "class",
value: "<string>",
description: "The collection from which to query objects.  <br/><br/>Note that if `class` is not provided, the response will not include any objects."
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
]
}
},
status: "OK",
code: 200,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "objects": [
    {
      "class": "<string>",
      "vectorWeights": {},
      "properties": {},
      "id": "<uuid>",
      "creationTimeUnix": "<long>",
      "lastUpdateTimeUnix": "<long>",
      "vector": [
        "<float>",
        "<float>"
      ],
      "vectors": {
        "cillum816": [
          "<float>",
          "<float>"
        ]
      },
      "tenant": "<string>",
      "additional": {
        "elit1": {}
      }
    },
    {
      "class": "<string>",
      "vectorWeights": {},
      "properties": {},
      "id": "<uuid>",
      "creationTimeUnix": "<long>",
      "lastUpdateTimeUnix": "<long>",
      "vector": [
        "<float>",
        "<float>"
      ],
      "vectors": {
        "id__4": [
          "<float>",
          "<float>"
        ]
      },
      "tenant": "<string>",
      "additional": {
        "utde": {},
        "anim__": {},
        "sintc_": {}
      }
    }
  ],
  "deprecations": [
    {
      "id": "<string>",
      "status": "<string>",
      "apiType": "<string>",
      "msg": "<string>",
      "mitigation": "<string>",
      "sinceVersion": "<string>",
      "plannedRemovalVersion": "<string>",
      "removedIn": "<string>",
      "removedTime": "<dateTime>",
      "sinceTime": "<dateTime>",
      "locations": [
        "<string>",
        "<string>"
      ]
    },
    {
      "id": "<string>",
      "status": "<string>",
      "apiType": "<string>",
      "msg": "<string>",
      "mitigation": "<string>",
      "sinceVersion": "<string>",
      "plannedRemovalVersion": "<string>",
      "removedIn": "<string>",
      "removedTime": "<dateTime>",
      "sinceTime": "<dateTime>",
      "locations": [
        "<string>",
        "<string>"
      ]
    }
  ],
  "totalResults": "<long>"
}"
},
{
name: "Malformed request.",
originalRequest: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/objects?after=<string>&offset=0&limit=25&include=<string>&sort=<string>&order=asc&class=<string>&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects"
],
query: [
{
key: "after",
value: "<string>",
description: "A threshold UUID of the objects to retrieve after, using an UUID-based ordering. This object is not part of the set. <br/><br/>Must be used with `class`, typically in conjunction with `limit`. <br/><br/>Note `after` cannot be used with `offset` or `sort`. <br/><br/>For a null value similar to offset=0, set an empty string in the request, i.e. `after=` or `after`."
},
{
key: "offset",
value: "0",
description: "The starting index of the result window. Note `offset` will retrieve `offset+limit` results and return `limit` results from the object with index `offset` onwards. Limited by the value of `QUERY_MAXIMUM_RESULTS`. <br/><br/>Should be used in conjunction with `limit`. <br/><br/>Cannot be used with `after`."
},
{
key: "limit",
value: "25",
description: "The maximum number of items to be returned per page. The default is 25 unless set otherwise as an environment variable."
},
{
key: "include",
value: "<string>",
description: "Include additional information, such as classification infos. Allowed values include: `classification`, `vector`, `interpretation`, `featureProjection` and other module-specific additional properties."
},
{
key: "sort",
value: "<string>",
description: "Name(s) of the property to sort by - e.g. `city`, or `country,city`."
},
{
key: "order",
value: "asc",
description: "Order parameter to tell how to order (asc or desc) data within given field. Should be used in conjunction with `sort` parameter. If providing multiple `sort` values, provide multiple `order` values in corresponding order, e.g.: `sort=author_name,title&order=desc,asc`."
},
{
key: "class",
value: "<string>",
description: "The collection from which to query objects.  <br/><br/>Note that if `class` is not provided, the response will not include any objects."
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
]
}
},
status: "Bad Request",
code: 400,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Unauthorized or invalid credentials.",
originalRequest: {
method: "GET",
header: [ ],
url: {
raw: "{{baseUrl}}/objects?after=<string>&offset=0&limit=25&include=<string>&sort=<string>&order=asc&class=<string>&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects"
],
query: [
{
key: "after",
value: "<string>",
description: "A threshold UUID of the objects to retrieve after, using an UUID-based ordering. This object is not part of the set. <br/><br/>Must be used with `class`, typically in conjunction with `limit`. <br/><br/>Note `after` cannot be used with `offset` or `sort`. <br/><br/>For a null value similar to offset=0, set an empty string in the request, i.e. `after=` or `after`."
},
{
key: "offset",
value: "0",
description: "The starting index of the result window. Note `offset` will retrieve `offset+limit` results and return `limit` results from the object with index `offset` onwards. Limited by the value of `QUERY_MAXIMUM_RESULTS`. <br/><br/>Should be used in conjunction with `limit`. <br/><br/>Cannot be used with `after`."
},
{
key: "limit",
value: "25",
description: "The maximum number of items to be returned per page. The default is 25 unless set otherwise as an environment variable."
},
{
key: "include",
value: "<string>",
description: "Include additional information, such as classification infos. Allowed values include: `classification`, `vector`, `interpretation`, `featureProjection` and other module-specific additional properties."
},
{
key: "sort",
value: "<string>",
description: "Name(s) of the property to sort by - e.g. `city`, or `country,city`."
},
{
key: "order",
value: "asc",
description: "Order parameter to tell how to order (asc or desc) data within given field. Should be used in conjunction with `sort` parameter. If providing multiple `sort` values, provide multiple `order` values in corresponding order, e.g.: `sort=author_name,title&order=desc,asc`."
},
{
key: "class",
value: "<string>",
description: "The collection from which to query objects.  <br/><br/>Note that if `class` is not provided, the response will not include any objects."
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
]
}
},
status: "Unauthorized",
code: 401,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Forbidden",
originalRequest: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/objects?after=<string>&offset=0&limit=25&include=<string>&sort=<string>&order=asc&class=<string>&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects"
],
query: [
{
key: "after",
value: "<string>",
description: "A threshold UUID of the objects to retrieve after, using an UUID-based ordering. This object is not part of the set. <br/><br/>Must be used with `class`, typically in conjunction with `limit`. <br/><br/>Note `after` cannot be used with `offset` or `sort`. <br/><br/>For a null value similar to offset=0, set an empty string in the request, i.e. `after=` or `after`."
},
{
key: "offset",
value: "0",
description: "The starting index of the result window. Note `offset` will retrieve `offset+limit` results and return `limit` results from the object with index `offset` onwards. Limited by the value of `QUERY_MAXIMUM_RESULTS`. <br/><br/>Should be used in conjunction with `limit`. <br/><br/>Cannot be used with `after`."
},
{
key: "limit",
value: "25",
description: "The maximum number of items to be returned per page. The default is 25 unless set otherwise as an environment variable."
},
{
key: "include",
value: "<string>",
description: "Include additional information, such as classification infos. Allowed values include: `classification`, `vector`, `interpretation`, `featureProjection` and other module-specific additional properties."
},
{
key: "sort",
value: "<string>",
description: "Name(s) of the property to sort by - e.g. `city`, or `country,city`."
},
{
key: "order",
value: "asc",
description: "Order parameter to tell how to order (asc or desc) data within given field. Should be used in conjunction with `sort` parameter. If providing multiple `sort` values, provide multiple `order` values in corresponding order, e.g.: `sort=author_name,title&order=desc,asc`."
},
{
key: "class",
value: "<string>",
description: "The collection from which to query objects.  <br/><br/>Note that if `class` is not provided, the response will not include any objects."
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
]
}
},
status: "Forbidden",
code: 403,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Successful query result but no resource was found.",
originalRequest: {
method: "GET",
header: [ ],
url: {
raw: "{{baseUrl}}/objects?after=<string>&offset=0&limit=25&include=<string>&sort=<string>&order=asc&class=<string>&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects"
],
query: [
{
key: "after",
value: "<string>",
description: "A threshold UUID of the objects to retrieve after, using an UUID-based ordering. This object is not part of the set. <br/><br/>Must be used with `class`, typically in conjunction with `limit`. <br/><br/>Note `after` cannot be used with `offset` or `sort`. <br/><br/>For a null value similar to offset=0, set an empty string in the request, i.e. `after=` or `after`."
},
{
key: "offset",
value: "0",
description: "The starting index of the result window. Note `offset` will retrieve `offset+limit` results and return `limit` results from the object with index `offset` onwards. Limited by the value of `QUERY_MAXIMUM_RESULTS`. <br/><br/>Should be used in conjunction with `limit`. <br/><br/>Cannot be used with `after`."
},
{
key: "limit",
value: "25",
description: "The maximum number of items to be returned per page. The default is 25 unless set otherwise as an environment variable."
},
{
key: "include",
value: "<string>",
description: "Include additional information, such as classification infos. Allowed values include: `classification`, `vector`, `interpretation`, `featureProjection` and other module-specific additional properties."
},
{
key: "sort",
value: "<string>",
description: "Name(s) of the property to sort by - e.g. `city`, or `country,city`."
},
{
key: "order",
value: "asc",
description: "Order parameter to tell how to order (asc or desc) data within given field. Should be used in conjunction with `sort` parameter. If providing multiple `sort` values, provide multiple `order` values in corresponding order, e.g.: `sort=author_name,title&order=desc,asc`."
},
{
key: "class",
value: "<string>",
description: "The collection from which to query objects.  <br/><br/>Note that if `class` is not provided, the response will not include any objects."
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
]
}
},
status: "Not Found",
code: 404,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Request body is well-formed (i.e., syntactically correct), but semantically erroneous. Are you sure the class is defined in the configuration file?",
originalRequest: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/objects?after=<string>&offset=0&limit=25&include=<string>&sort=<string>&order=asc&class=<string>&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects"
],
query: [
{
key: "after",
value: "<string>",
description: "A threshold UUID of the objects to retrieve after, using an UUID-based ordering. This object is not part of the set. <br/><br/>Must be used with `class`, typically in conjunction with `limit`. <br/><br/>Note `after` cannot be used with `offset` or `sort`. <br/><br/>For a null value similar to offset=0, set an empty string in the request, i.e. `after=` or `after`."
},
{
key: "offset",
value: "0",
description: "The starting index of the result window. Note `offset` will retrieve `offset+limit` results and return `limit` results from the object with index `offset` onwards. Limited by the value of `QUERY_MAXIMUM_RESULTS`. <br/><br/>Should be used in conjunction with `limit`. <br/><br/>Cannot be used with `after`."
},
{
key: "limit",
value: "25",
description: "The maximum number of items to be returned per page. The default is 25 unless set otherwise as an environment variable."
},
{
key: "include",
value: "<string>",
description: "Include additional information, such as classification infos. Allowed values include: `classification`, `vector`, `interpretation`, `featureProjection` and other module-specific additional properties."
},
{
key: "sort",
value: "<string>",
description: "Name(s) of the property to sort by - e.g. `city`, or `country,city`."
},
{
key: "order",
value: "asc",
description: "Order parameter to tell how to order (asc or desc) data within given field. Should be used in conjunction with `sort` parameter. If providing multiple `sort` values, provide multiple `order` values in corresponding order, e.g.: `sort=author_name,title&order=desc,asc`."
},
{
key: "class",
value: "<string>",
description: "The collection from which to query objects.  <br/><br/>Note that if `class` is not provided, the response will not include any objects."
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
]
}
},
status: "Unprocessable Entity (WebDAV) (RFC 4918)",
code: 422,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error.",
originalRequest: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/objects?after=<string>&offset=0&limit=25&include=<string>&sort=<string>&order=asc&class=<string>&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"objects"
],
query: [
{
key: "after",
value: "<string>",
description: "A threshold UUID of the objects to retrieve after, using an UUID-based ordering. This object is not part of the set. <br/><br/>Must be used with `class`, typically in conjunction with `limit`. <br/><br/>Note `after` cannot be used with `offset` or `sort`. <br/><br/>For a null value similar to offset=0, set an empty string in the request, i.e. `after=` or `after`."
},
{
key: "offset",
value: "0",
description: "The starting index of the result window. Note `offset` will retrieve `offset+limit` results and return `limit` results from the object with index `offset` onwards. Limited by the value of `QUERY_MAXIMUM_RESULTS`. <br/><br/>Should be used in conjunction with `limit`. <br/><br/>Cannot be used with `after`."
},
{
key: "limit",
value: "25",
description: "The maximum number of items to be returned per page. The default is 25 unless set otherwise as an environment variable."
},
{
key: "include",
value: "<string>",
description: "Include additional information, such as classification infos. Allowed values include: `classification`, `vector`, `interpretation`, `featureProjection` and other module-specific additional properties."
},
{
key: "sort",
value: "<string>",
description: "Name(s) of the property to sort by - e.g. `city`, or `country,city`."
},
{
key: "order",
value: "asc",
description: "Order parameter to tell how to order (asc or desc) data within given field. Should be used in conjunction with `sort` parameter. If providing multiple `sort` values, provide multiple `order` values in corresponding order, e.g.: `sort=author_name,title&order=desc,asc`."
},
{
key: "class",
value: "<string>",
description: "The collection from which to query objects.  <br/><br/>Note that if `class` is not provided, the response will not include any objects."
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
]
}
},
status: "Internal Server Error",
code: 500,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
}
]
},
{
name: "Create a new object.",
request: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<string>",
  "vectorWeights": {},
  "properties": {},
  "id": "<uuid>",
  "creationTimeUnix": "<long>",
  "lastUpdateTimeUnix": "<long>",
  "vector": [
    "<float>",
    "<float>"
  ],
  "vectors": {
    "sint_b38": [
      "<float>",
      "<float>"
    ]
  },
  "tenant": "<string>",
  "additional": {
    "enim9": {},
    "sunt_6a": {},
    "voluptate_e": {}
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects?consistency_level=QUORUM",
host: [
"{{baseUrl}}"
],
path: [
"objects"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
}
]
},
description: "Create a new object. <br/><br/>Meta-data and schema values are validated. <br/><br/>**Note: Use `/batch` for importing many objects**: <br/>If you plan on importing a large number of objects, it's much more efficient to use the `/batch` endpoint. Otherwise, sending multiple single requests sequentially would incur a large performance penalty. <br/><br/>**Note: idempotence of `/objects`**: <br/>POST /objects will fail if an id is provided which already exists in the class. To update an existing object with the objects endpoint, use the PUT or PATCH method."
},
response: [
{
name: "Object created.",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<string>",
  "vectorWeights": {},
  "properties": {},
  "id": "<uuid>",
  "creationTimeUnix": "<long>",
  "lastUpdateTimeUnix": "<long>",
  "vector": [
    "<float>",
    "<float>"
  ],
  "vectors": {
    "sint_b38": [
      "<float>",
      "<float>"
    ]
  },
  "tenant": "<string>",
  "additional": {
    "enim9": {},
    "sunt_6a": {},
    "voluptate_e": {}
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects?consistency_level=QUORUM",
host: [
"{{baseUrl}}"
],
path: [
"objects"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
}
]
}
},
status: "OK",
code: 200,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "class": "<string>",
  "vectorWeights": {},
  "properties": {},
  "id": "<uuid>",
  "creationTimeUnix": "<long>",
  "lastUpdateTimeUnix": "<long>",
  "vector": [
    "<float>",
    "<float>"
  ],
  "vectors": {
    "sint_b38": [
      "<float>",
      "<float>"
    ]
  },
  "tenant": "<string>",
  "additional": {
    "enim9": {},
    "sunt_6a": {},
    "voluptate_e": {}
  }
}"
},
{
name: "Malformed request.",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<string>",
  "vectorWeights": {},
  "properties": {},
  "id": "<uuid>",
  "creationTimeUnix": "<long>",
  "lastUpdateTimeUnix": "<long>",
  "vector": [
    "<float>",
    "<float>"
  ],
  "vectors": {
    "sint_b38": [
      "<float>",
      "<float>"
    ]
  },
  "tenant": "<string>",
  "additional": {
    "enim9": {},
    "sunt_6a": {},
    "voluptate_e": {}
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects?consistency_level=QUORUM",
host: [
"{{baseUrl}}"
],
path: [
"objects"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
}
]
}
},
status: "Bad Request",
code: 400,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Unauthorized or invalid credentials.",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<string>",
  "vectorWeights": {},
  "properties": {},
  "id": "<uuid>",
  "creationTimeUnix": "<long>",
  "lastUpdateTimeUnix": "<long>",
  "vector": [
    "<float>",
    "<float>"
  ],
  "vectors": {
    "sint_b38": [
      "<float>",
      "<float>"
    ]
  },
  "tenant": "<string>",
  "additional": {
    "enim9": {},
    "sunt_6a": {},
    "voluptate_e": {}
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects?consistency_level=QUORUM",
host: [
"{{baseUrl}}"
],
path: [
"objects"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
}
]
}
},
status: "Unauthorized",
code: 401,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Forbidden",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<string>",
  "vectorWeights": {},
  "properties": {},
  "id": "<uuid>",
  "creationTimeUnix": "<long>",
  "lastUpdateTimeUnix": "<long>",
  "vector": [
    "<float>",
    "<float>"
  ],
  "vectors": {
    "sint_b38": [
      "<float>",
      "<float>"
    ]
  },
  "tenant": "<string>",
  "additional": {
    "enim9": {},
    "sunt_6a": {},
    "voluptate_e": {}
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects?consistency_level=QUORUM",
host: [
"{{baseUrl}}"
],
path: [
"objects"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
}
]
}
},
status: "Forbidden",
code: 403,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Request body is well-formed (i.e., syntactically correct), but semantically erroneous. Are you sure the class is defined in the configuration file?",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<string>",
  "vectorWeights": {},
  "properties": {},
  "id": "<uuid>",
  "creationTimeUnix": "<long>",
  "lastUpdateTimeUnix": "<long>",
  "vector": [
    "<float>",
    "<float>"
  ],
  "vectors": {
    "sint_b38": [
      "<float>",
      "<float>"
    ]
  },
  "tenant": "<string>",
  "additional": {
    "enim9": {},
    "sunt_6a": {},
    "voluptate_e": {}
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects?consistency_level=QUORUM",
host: [
"{{baseUrl}}"
],
path: [
"objects"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
}
]
}
},
status: "Unprocessable Entity (WebDAV) (RFC 4918)",
code: 422,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error.",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<string>",
  "vectorWeights": {},
  "properties": {},
  "id": "<uuid>",
  "creationTimeUnix": "<long>",
  "lastUpdateTimeUnix": "<long>",
  "vector": [
    "<float>",
    "<float>"
  ],
  "vectors": {
    "sint_b38": [
      "<float>",
      "<float>"
    ]
  },
  "tenant": "<string>",
  "additional": {
    "enim9": {},
    "sunt_6a": {},
    "voluptate_e": {}
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/objects?consistency_level=QUORUM",
host: [
"{{baseUrl}}"
],
path: [
"objects"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
}
]
}
},
status: "Internal Server Error",
code: 500,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
}
]
}
]
},
{
name: "batch",
item: [
{
name: "objects",
item: [
{
name: "Batch create new objects.",
request: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "fields": [
    "ALL",
    "ALL"
  ],
  "objects": [
    {
      "class": "<string>",
      "vectorWeights": {},
      "properties": {},
      "id": "<uuid>",
      "creationTimeUnix": "<long>",
      "lastUpdateTimeUnix": "<long>",
      "vector": [
        "<float>",
        "<float>"
      ],
      "vectors": {
        "do_66a": [
          "<float>",
          "<float>"
        ]
      },
      "tenant": "<string>",
      "additional": {
        "culpa984": {},
        "officia_e_": {}
      }
    },
    {
      "class": "<string>",
      "vectorWeights": {},
      "properties": {},
      "id": "<uuid>",
      "creationTimeUnix": "<long>",
      "lastUpdateTimeUnix": "<long>",
      "vector": [
        "<float>",
        "<float>"
      ],
      "vectors": {
        "ut_5": [
          "<float>",
          "<float>"
        ],
        "exercitation66e": [
          "<float>",
          "<float>"
        ]
      },
      "tenant": "<string>",
      "additional": {
        "dolora4": {}
      }
    }
  ]
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/batch/objects?consistency_level=QUORUM",
host: [
"{{baseUrl}}"
],
path: [
"batch",
"objects"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
}
]
},
description: "Create new objects in bulk. <br/><br/>Meta-data and schema values are validated. <br/><br/>**Note: idempotence of `/batch/objects`**: <br/>`POST /batch/objects` is idempotent, and will overwrite any existing object given the same id."
},
response: [
{
name: "Request succeeded, see response body to get detailed information about each batched item.",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "fields": [
    "ALL",
    "ALL"
  ],
  "objects": [
    {
      "class": "<string>",
      "vectorWeights": {},
      "properties": {},
      "id": "<uuid>",
      "creationTimeUnix": "<long>",
      "lastUpdateTimeUnix": "<long>",
      "vector": [
        "<float>",
        "<float>"
      ],
      "vectors": {
        "do_66a": [
          "<float>",
          "<float>"
        ]
      },
      "tenant": "<string>",
      "additional": {
        "culpa984": {},
        "officia_e_": {}
      }
    },
    {
      "class": "<string>",
      "vectorWeights": {},
      "properties": {},
      "id": "<uuid>",
      "creationTimeUnix": "<long>",
      "lastUpdateTimeUnix": "<long>",
      "vector": [
        "<float>",
        "<float>"
      ],
      "vectors": {
        "ut_5": [
          "<float>",
          "<float>"
        ],
        "exercitation66e": [
          "<float>",
          "<float>"
        ]
      },
      "tenant": "<string>",
      "additional": {
        "dolora4": {}
      }
    }
  ]
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/batch/objects?consistency_level=QUORUM",
host: [
"{{baseUrl}}"
],
path: [
"batch",
"objects"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
}
]
}
},
status: "OK",
code: 200,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "[
  {
    "class": "<string>",
    "vectorWeights": {},
    "properties": {},
    "id": "<uuid>",
    "creationTimeUnix": "<long>",
    "lastUpdateTimeUnix": "<long>",
    "vector": [
      "<float>",
      "<float>"
    ],
    "vectors": {
      "nisi_50": [
        "<float>",
        "<float>"
      ],
      "eacf0": [
        "<float>",
        "<float>"
      ]
    },
    "tenant": "<string>",
    "additional": {
      "exercitation_c9": {}
    },
    "deprecations": [
      {
        "id": "<string>",
        "status": "<string>",
        "apiType": "<string>",
        "msg": "<string>",
        "mitigation": "<string>",
        "sinceVersion": "<string>",
        "plannedRemovalVersion": "<string>",
        "removedIn": "<string>",
        "removedTime": "<dateTime>",
        "sinceTime": "<dateTime>",
        "locations": [
          "<string>",
          "<string>"
        ]
      },
      {
        "id": "<string>",
        "status": "<string>",
        "apiType": "<string>",
        "msg": "<string>",
        "mitigation": "<string>",
        "sinceVersion": "<string>",
        "plannedRemovalVersion": "<string>",
        "removedIn": "<string>",
        "removedTime": "<dateTime>",
        "sinceTime": "<dateTime>",
        "locations": [
          "<string>",
          "<string>"
        ]
      }
    ],
    "result": {
      "status": "SUCCESS",
      "errors": {
        "error": [
          {
            "message": "<string>"
          },
          {
            "message": "<string>"
          }
        ]
      }
    }
  },
  {
    "class": "<string>",
    "vectorWeights": {},
    "properties": {},
    "id": "<uuid>",
    "creationTimeUnix": "<long>",
    "lastUpdateTimeUnix": "<long>",
    "vector": [
      "<float>",
      "<float>"
    ],
    "vectors": {
      "irure_019": [
        "<float>",
        "<float>"
      ],
      "aliqua8": [
        "<float>",
        "<float>"
      ],
      "fugiat_fd": [
        "<float>",
        "<float>"
      ]
    },
    "tenant": "<string>",
    "additional": {
      "irure_0c": {}
    },
    "deprecations": [
      {
        "id": "<string>",
        "status": "<string>",
        "apiType": "<string>",
        "msg": "<string>",
        "mitigation": "<string>",
        "sinceVersion": "<string>",
        "plannedRemovalVersion": "<string>",
        "removedIn": "<string>",
        "removedTime": "<dateTime>",
        "sinceTime": "<dateTime>",
        "locations": [
          "<string>",
          "<string>"
        ]
      },
      {
        "id": "<string>",
        "status": "<string>",
        "apiType": "<string>",
        "msg": "<string>",
        "mitigation": "<string>",
        "sinceVersion": "<string>",
        "plannedRemovalVersion": "<string>",
        "removedIn": "<string>",
        "removedTime": "<dateTime>",
        "sinceTime": "<dateTime>",
        "locations": [
          "<string>",
          "<string>"
        ]
      }
    ],
    "result": {
      "status": "SUCCESS",
      "errors": {
        "error": [
          {
            "message": "<string>"
          },
          {
            "message": "<string>"
          }
        ]
      }
    }
  }
]"
},
{
name: "Malformed request.",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "fields": [
    "ALL",
    "ALL"
  ],
  "objects": [
    {
      "class": "<string>",
      "vectorWeights": {},
      "properties": {},
      "id": "<uuid>",
      "creationTimeUnix": "<long>",
      "lastUpdateTimeUnix": "<long>",
      "vector": [
        "<float>",
        "<float>"
      ],
      "vectors": {
        "do_66a": [
          "<float>",
          "<float>"
        ]
      },
      "tenant": "<string>",
      "additional": {
        "culpa984": {},
        "officia_e_": {}
      }
    },
    {
      "class": "<string>",
      "vectorWeights": {},
      "properties": {},
      "id": "<uuid>",
      "creationTimeUnix": "<long>",
      "lastUpdateTimeUnix": "<long>",
      "vector": [
        "<float>",
        "<float>"
      ],
      "vectors": {
        "ut_5": [
          "<float>",
          "<float>"
        ],
        "exercitation66e": [
          "<float>",
          "<float>"
        ]
      },
      "tenant": "<string>",
      "additional": {
        "dolora4": {}
      }
    }
  ]
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/batch/objects?consistency_level=QUORUM",
host: [
"{{baseUrl}}"
],
path: [
"batch",
"objects"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
}
]
}
},
status: "Bad Request",
code: 400,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Unauthorized or invalid credentials.",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "fields": [
    "ALL",
    "ALL"
  ],
  "objects": [
    {
      "class": "<string>",
      "vectorWeights": {},
      "properties": {},
      "id": "<uuid>",
      "creationTimeUnix": "<long>",
      "lastUpdateTimeUnix": "<long>",
      "vector": [
        "<float>",
        "<float>"
      ],
      "vectors": {
        "do_66a": [
          "<float>",
          "<float>"
        ]
      },
      "tenant": "<string>",
      "additional": {
        "culpa984": {},
        "officia_e_": {}
      }
    },
    {
      "class": "<string>",
      "vectorWeights": {},
      "properties": {},
      "id": "<uuid>",
      "creationTimeUnix": "<long>",
      "lastUpdateTimeUnix": "<long>",
      "vector": [
        "<float>",
        "<float>"
      ],
      "vectors": {
        "ut_5": [
          "<float>",
          "<float>"
        ],
        "exercitation66e": [
          "<float>",
          "<float>"
        ]
      },
      "tenant": "<string>",
      "additional": {
        "dolora4": {}
      }
    }
  ]
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/batch/objects?consistency_level=QUORUM",
host: [
"{{baseUrl}}"
],
path: [
"batch",
"objects"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
}
]
}
},
status: "Unauthorized",
code: 401,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Forbidden",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "fields": [
    "ALL",
    "ALL"
  ],
  "objects": [
    {
      "class": "<string>",
      "vectorWeights": {},
      "properties": {},
      "id": "<uuid>",
      "creationTimeUnix": "<long>",
      "lastUpdateTimeUnix": "<long>",
      "vector": [
        "<float>",
        "<float>"
      ],
      "vectors": {
        "do_66a": [
          "<float>",
          "<float>"
        ]
      },
      "tenant": "<string>",
      "additional": {
        "culpa984": {},
        "officia_e_": {}
      }
    },
    {
      "class": "<string>",
      "vectorWeights": {},
      "properties": {},
      "id": "<uuid>",
      "creationTimeUnix": "<long>",
      "lastUpdateTimeUnix": "<long>",
      "vector": [
        "<float>",
        "<float>"
      ],
      "vectors": {
        "ut_5": [
          "<float>",
          "<float>"
        ],
        "exercitation66e": [
          "<float>",
          "<float>"
        ]
      },
      "tenant": "<string>",
      "additional": {
        "dolora4": {}
      }
    }
  ]
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/batch/objects?consistency_level=QUORUM",
host: [
"{{baseUrl}}"
],
path: [
"batch",
"objects"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
}
]
}
},
status: "Forbidden",
code: 403,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Request body is well-formed (i.e., syntactically correct), but semantically erroneous. Are you sure the class is defined in the configuration file?",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "fields": [
    "ALL",
    "ALL"
  ],
  "objects": [
    {
      "class": "<string>",
      "vectorWeights": {},
      "properties": {},
      "id": "<uuid>",
      "creationTimeUnix": "<long>",
      "lastUpdateTimeUnix": "<long>",
      "vector": [
        "<float>",
        "<float>"
      ],
      "vectors": {
        "do_66a": [
          "<float>",
          "<float>"
        ]
      },
      "tenant": "<string>",
      "additional": {
        "culpa984": {},
        "officia_e_": {}
      }
    },
    {
      "class": "<string>",
      "vectorWeights": {},
      "properties": {},
      "id": "<uuid>",
      "creationTimeUnix": "<long>",
      "lastUpdateTimeUnix": "<long>",
      "vector": [
        "<float>",
        "<float>"
      ],
      "vectors": {
        "ut_5": [
          "<float>",
          "<float>"
        ],
        "exercitation66e": [
          "<float>",
          "<float>"
        ]
      },
      "tenant": "<string>",
      "additional": {
        "dolora4": {}
      }
    }
  ]
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/batch/objects?consistency_level=QUORUM",
host: [
"{{baseUrl}}"
],
path: [
"batch",
"objects"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
}
]
}
},
status: "Unprocessable Entity (WebDAV) (RFC 4918)",
code: 422,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error.",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "fields": [
    "ALL",
    "ALL"
  ],
  "objects": [
    {
      "class": "<string>",
      "vectorWeights": {},
      "properties": {},
      "id": "<uuid>",
      "creationTimeUnix": "<long>",
      "lastUpdateTimeUnix": "<long>",
      "vector": [
        "<float>",
        "<float>"
      ],
      "vectors": {
        "do_66a": [
          "<float>",
          "<float>"
        ]
      },
      "tenant": "<string>",
      "additional": {
        "culpa984": {},
        "officia_e_": {}
      }
    },
    {
      "class": "<string>",
      "vectorWeights": {},
      "properties": {},
      "id": "<uuid>",
      "creationTimeUnix": "<long>",
      "lastUpdateTimeUnix": "<long>",
      "vector": [
        "<float>",
        "<float>"
      ],
      "vectors": {
        "ut_5": [
          "<float>",
          "<float>"
        ],
        "exercitation66e": [
          "<float>",
          "<float>"
        ]
      },
      "tenant": "<string>",
      "additional": {
        "dolora4": {}
      }
    }
  ]
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/batch/objects?consistency_level=QUORUM",
host: [
"{{baseUrl}}"
],
path: [
"batch",
"objects"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
}
]
}
},
status: "Internal Server Error",
code: 500,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
}
]
},
{
name: "Batch delete objects.",
request: {
method: "DELETE",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "match": {
    "class": "<string>",
    "where": {
      "operands": [
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        },
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        }
      ],
      "operator": "GreaterThanEqual",
      "path": [
        "<string>",
        "<string>"
      ],
      "valueInt": "<long>",
      "valueNumber": "<number>",
      "valueBoolean": "<boolean>",
      "valueString": "<string>",
      "valueText": "<string>",
      "valueDate": "<string>",
      "valueIntArray": [
        "<long>",
        "<long>"
      ],
      "valueNumberArray": [
        "<number>",
        "<number>"
      ],
      "valueBooleanArray": [
        "<boolean>",
        "<boolean>"
      ],
      "valueStringArray": [
        "<string>",
        "<string>"
      ],
      "valueTextArray": [
        "<string>",
        "<string>"
      ],
      "valueDateArray": [
        "<string>",
        "<string>"
      ],
      "valueGeoRange": {
        "geoCoordinates": {
          "latitude": "<float>",
          "longitude": "<float>"
        },
        "distance": {
          "max": "<number>"
        }
      }
    }
  },
  "output": "minimal",
  "dryRun": false
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/batch/objects?consistency_level=QUORUM&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"batch",
"objects"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
]
},
description: "Batch delete objects that match a particular filter. <br/><br/>The request body takes a single `where` filter and will delete all objects matched. <br/><br/>Note that there is a limit to the number of objects to be deleted at once using this filter, in order to protect against unexpected memory surges and very-long-running requests. The default limit is 10,000 and may be configured by setting the `QUERY_MAXIMUM_RESULTS` environment variable. <br/><br/>Objects are deleted in the same order that they would be returned in an equivalent Get query. To delete more objects than the limit, run the same query multiple times."
},
response: [
{
name: "Request succeeded, see response body to get detailed information about each batched item.",
originalRequest: {
method: "DELETE",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "match": {
    "class": "<string>",
    "where": {
      "operands": [
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        },
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        }
      ],
      "operator": "GreaterThanEqual",
      "path": [
        "<string>",
        "<string>"
      ],
      "valueInt": "<long>",
      "valueNumber": "<number>",
      "valueBoolean": "<boolean>",
      "valueString": "<string>",
      "valueText": "<string>",
      "valueDate": "<string>",
      "valueIntArray": [
        "<long>",
        "<long>"
      ],
      "valueNumberArray": [
        "<number>",
        "<number>"
      ],
      "valueBooleanArray": [
        "<boolean>",
        "<boolean>"
      ],
      "valueStringArray": [
        "<string>",
        "<string>"
      ],
      "valueTextArray": [
        "<string>",
        "<string>"
      ],
      "valueDateArray": [
        "<string>",
        "<string>"
      ],
      "valueGeoRange": {
        "geoCoordinates": {
          "latitude": "<float>",
          "longitude": "<float>"
        },
        "distance": {
          "max": "<number>"
        }
      }
    }
  },
  "output": "minimal",
  "dryRun": false
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/batch/objects?consistency_level=QUORUM&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"batch",
"objects"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
]
}
},
status: "OK",
code: 200,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "match": {
    "class": "<string>",
    "where": {
      "operands": [
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        },
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        }
      ],
      "operator": "ContainsAll",
      "path": [
        "<string>",
        "<string>"
      ],
      "valueInt": "<long>",
      "valueNumber": "<number>",
      "valueBoolean": "<boolean>",
      "valueString": "<string>",
      "valueText": "<string>",
      "valueDate": "<string>",
      "valueIntArray": [
        "<long>",
        "<long>"
      ],
      "valueNumberArray": [
        "<number>",
        "<number>"
      ],
      "valueBooleanArray": [
        "<boolean>",
        "<boolean>"
      ],
      "valueStringArray": [
        "<string>",
        "<string>"
      ],
      "valueTextArray": [
        "<string>",
        "<string>"
      ],
      "valueDateArray": [
        "<string>",
        "<string>"
      ],
      "valueGeoRange": {
        "geoCoordinates": {
          "latitude": "<float>",
          "longitude": "<float>"
        },
        "distance": {
          "max": "<number>"
        }
      }
    }
  },
  "output": "minimal",
  "dryRun": false,
  "results": {
    "matches": "<number>",
    "limit": "<number>",
    "successful": "<number>",
    "failed": "<number>",
    "objects": [
      {
        "id": "<uuid>",
        "status": "SUCCESS",
        "errors": {
          "error": [
            {
              "message": "<string>"
            },
            {
              "message": "<string>"
            }
          ]
        }
      },
      {
        "id": "<uuid>",
        "status": "SUCCESS",
        "errors": {
          "error": [
            {
              "message": "<string>"
            },
            {
              "message": "<string>"
            }
          ]
        }
      }
    ]
  }
}"
},
{
name: "Malformed request.",
originalRequest: {
method: "DELETE",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "match": {
    "class": "<string>",
    "where": {
      "operands": [
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        },
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        }
      ],
      "operator": "GreaterThanEqual",
      "path": [
        "<string>",
        "<string>"
      ],
      "valueInt": "<long>",
      "valueNumber": "<number>",
      "valueBoolean": "<boolean>",
      "valueString": "<string>",
      "valueText": "<string>",
      "valueDate": "<string>",
      "valueIntArray": [
        "<long>",
        "<long>"
      ],
      "valueNumberArray": [
        "<number>",
        "<number>"
      ],
      "valueBooleanArray": [
        "<boolean>",
        "<boolean>"
      ],
      "valueStringArray": [
        "<string>",
        "<string>"
      ],
      "valueTextArray": [
        "<string>",
        "<string>"
      ],
      "valueDateArray": [
        "<string>",
        "<string>"
      ],
      "valueGeoRange": {
        "geoCoordinates": {
          "latitude": "<float>",
          "longitude": "<float>"
        },
        "distance": {
          "max": "<number>"
        }
      }
    }
  },
  "output": "minimal",
  "dryRun": false
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/batch/objects?consistency_level=QUORUM&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"batch",
"objects"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
]
}
},
status: "Bad Request",
code: 400,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Unauthorized or invalid credentials.",
originalRequest: {
method: "DELETE",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "match": {
    "class": "<string>",
    "where": {
      "operands": [
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        },
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        }
      ],
      "operator": "GreaterThanEqual",
      "path": [
        "<string>",
        "<string>"
      ],
      "valueInt": "<long>",
      "valueNumber": "<number>",
      "valueBoolean": "<boolean>",
      "valueString": "<string>",
      "valueText": "<string>",
      "valueDate": "<string>",
      "valueIntArray": [
        "<long>",
        "<long>"
      ],
      "valueNumberArray": [
        "<number>",
        "<number>"
      ],
      "valueBooleanArray": [
        "<boolean>",
        "<boolean>"
      ],
      "valueStringArray": [
        "<string>",
        "<string>"
      ],
      "valueTextArray": [
        "<string>",
        "<string>"
      ],
      "valueDateArray": [
        "<string>",
        "<string>"
      ],
      "valueGeoRange": {
        "geoCoordinates": {
          "latitude": "<float>",
          "longitude": "<float>"
        },
        "distance": {
          "max": "<number>"
        }
      }
    }
  },
  "output": "minimal",
  "dryRun": false
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/batch/objects?consistency_level=QUORUM&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"batch",
"objects"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
]
}
},
status: "Unauthorized",
code: 401,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Forbidden",
originalRequest: {
method: "DELETE",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "match": {
    "class": "<string>",
    "where": {
      "operands": [
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        },
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        }
      ],
      "operator": "GreaterThanEqual",
      "path": [
        "<string>",
        "<string>"
      ],
      "valueInt": "<long>",
      "valueNumber": "<number>",
      "valueBoolean": "<boolean>",
      "valueString": "<string>",
      "valueText": "<string>",
      "valueDate": "<string>",
      "valueIntArray": [
        "<long>",
        "<long>"
      ],
      "valueNumberArray": [
        "<number>",
        "<number>"
      ],
      "valueBooleanArray": [
        "<boolean>",
        "<boolean>"
      ],
      "valueStringArray": [
        "<string>",
        "<string>"
      ],
      "valueTextArray": [
        "<string>",
        "<string>"
      ],
      "valueDateArray": [
        "<string>",
        "<string>"
      ],
      "valueGeoRange": {
        "geoCoordinates": {
          "latitude": "<float>",
          "longitude": "<float>"
        },
        "distance": {
          "max": "<number>"
        }
      }
    }
  },
  "output": "minimal",
  "dryRun": false
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/batch/objects?consistency_level=QUORUM&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"batch",
"objects"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
]
}
},
status: "Forbidden",
code: 403,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Request body is well-formed (i.e., syntactically correct), but semantically erroneous. Are you sure the class is defined in the configuration file?",
originalRequest: {
method: "DELETE",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "match": {
    "class": "<string>",
    "where": {
      "operands": [
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        },
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        }
      ],
      "operator": "GreaterThanEqual",
      "path": [
        "<string>",
        "<string>"
      ],
      "valueInt": "<long>",
      "valueNumber": "<number>",
      "valueBoolean": "<boolean>",
      "valueString": "<string>",
      "valueText": "<string>",
      "valueDate": "<string>",
      "valueIntArray": [
        "<long>",
        "<long>"
      ],
      "valueNumberArray": [
        "<number>",
        "<number>"
      ],
      "valueBooleanArray": [
        "<boolean>",
        "<boolean>"
      ],
      "valueStringArray": [
        "<string>",
        "<string>"
      ],
      "valueTextArray": [
        "<string>",
        "<string>"
      ],
      "valueDateArray": [
        "<string>",
        "<string>"
      ],
      "valueGeoRange": {
        "geoCoordinates": {
          "latitude": "<float>",
          "longitude": "<float>"
        },
        "distance": {
          "max": "<number>"
        }
      }
    }
  },
  "output": "minimal",
  "dryRun": false
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/batch/objects?consistency_level=QUORUM&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"batch",
"objects"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
]
}
},
status: "Unprocessable Entity (WebDAV) (RFC 4918)",
code: 422,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error.",
originalRequest: {
method: "DELETE",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "match": {
    "class": "<string>",
    "where": {
      "operands": [
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        },
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        }
      ],
      "operator": "GreaterThanEqual",
      "path": [
        "<string>",
        "<string>"
      ],
      "valueInt": "<long>",
      "valueNumber": "<number>",
      "valueBoolean": "<boolean>",
      "valueString": "<string>",
      "valueText": "<string>",
      "valueDate": "<string>",
      "valueIntArray": [
        "<long>",
        "<long>"
      ],
      "valueNumberArray": [
        "<number>",
        "<number>"
      ],
      "valueBooleanArray": [
        "<boolean>",
        "<boolean>"
      ],
      "valueStringArray": [
        "<string>",
        "<string>"
      ],
      "valueTextArray": [
        "<string>",
        "<string>"
      ],
      "valueDateArray": [
        "<string>",
        "<string>"
      ],
      "valueGeoRange": {
        "geoCoordinates": {
          "latitude": "<float>",
          "longitude": "<float>"
        },
        "distance": {
          "max": "<number>"
        }
      }
    }
  },
  "output": "minimal",
  "dryRun": false
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/batch/objects?consistency_level=QUORUM&tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"batch",
"objects"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
},
{
key: "tenant",
value: "<string>",
description: "Specifies the tenant in a request targeting a multi-tenant collection"
}
]
}
},
status: "Internal Server Error",
code: 500,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
}
]
}
]
},
{
name: "references",
item: [
{
name: "Batch create cross-references.",
request: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "[
  {
    "from": "<uri>",
    "to": "<uri>",
    "tenant": "<string>"
  },
  {
    "from": "<uri>",
    "to": "<uri>",
    "tenant": "<string>"
  }
]",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/batch/references?consistency_level=QUORUM",
host: [
"{{baseUrl}}"
],
path: [
"batch",
"references"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
}
]
},
description: "Batch create cross-references between collections items (objects or objects) in bulk."
},
response: [
{
name: "Request Successful. Warning: A successful request does not guarantee that every batched reference was successfully created. Inspect the response body to see which references succeeded and which failed.",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "[
  {
    "from": "<uri>",
    "to": "<uri>",
    "tenant": "<string>"
  },
  {
    "from": "<uri>",
    "to": "<uri>",
    "tenant": "<string>"
  }
]",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/batch/references?consistency_level=QUORUM",
host: [
"{{baseUrl}}"
],
path: [
"batch",
"references"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
}
]
}
},
status: "OK",
code: 200,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "[
  {
    "from": "<uri>",
    "to": "<uri>",
    "tenant": "<string>",
    "result": {
      "status": "SUCCESS",
      "errors": {
        "error": [
          {
            "message": "<string>"
          },
          {
            "message": "<string>"
          }
        ]
      }
    }
  },
  {
    "from": "<uri>",
    "to": "<uri>",
    "tenant": "<string>",
    "result": {
      "status": "SUCCESS",
      "errors": {
        "error": [
          {
            "message": "<string>"
          },
          {
            "message": "<string>"
          }
        ]
      }
    }
  }
]"
},
{
name: "Malformed request.",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "[
  {
    "from": "<uri>",
    "to": "<uri>",
    "tenant": "<string>"
  },
  {
    "from": "<uri>",
    "to": "<uri>",
    "tenant": "<string>"
  }
]",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/batch/references?consistency_level=QUORUM",
host: [
"{{baseUrl}}"
],
path: [
"batch",
"references"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
}
]
}
},
status: "Bad Request",
code: 400,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Unauthorized or invalid credentials.",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "[
  {
    "from": "<uri>",
    "to": "<uri>",
    "tenant": "<string>"
  },
  {
    "from": "<uri>",
    "to": "<uri>",
    "tenant": "<string>"
  }
]",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/batch/references?consistency_level=QUORUM",
host: [
"{{baseUrl}}"
],
path: [
"batch",
"references"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
}
]
}
},
status: "Unauthorized",
code: 401,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Forbidden",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "[
  {
    "from": "<uri>",
    "to": "<uri>",
    "tenant": "<string>"
  },
  {
    "from": "<uri>",
    "to": "<uri>",
    "tenant": "<string>"
  }
]",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/batch/references?consistency_level=QUORUM",
host: [
"{{baseUrl}}"
],
path: [
"batch",
"references"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
}
]
}
},
status: "Forbidden",
code: 403,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Request body is well-formed (i.e., syntactically correct), but semantically erroneous. Are you sure the class is defined in the configuration file?",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "[
  {
    "from": "<uri>",
    "to": "<uri>",
    "tenant": "<string>"
  },
  {
    "from": "<uri>",
    "to": "<uri>",
    "tenant": "<string>"
  }
]",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/batch/references?consistency_level=QUORUM",
host: [
"{{baseUrl}}"
],
path: [
"batch",
"references"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
}
]
}
},
status: "Unprocessable Entity (WebDAV) (RFC 4918)",
code: 422,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error.",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "[
  {
    "from": "<uri>",
    "to": "<uri>",
    "tenant": "<string>"
  },
  {
    "from": "<uri>",
    "to": "<uri>",
    "tenant": "<string>"
  }
]",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/batch/references?consistency_level=QUORUM",
host: [
"{{baseUrl}}"
],
path: [
"batch",
"references"
],
query: [
{
key: "consistency_level",
value: "QUORUM",
description: "Determines how many replicas must acknowledge a request before it is considered successful"
}
]
}
},
status: "Internal Server Error",
code: 500,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
}
]
}
]
}
]
},
{
name: "graphql",
item: [
{
name: "batch",
item: [
{
name: "Perform batched GraphQL queries.",
request: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "[
  {
    "operationName": "<string>",
    "query": "<string>",
    "variables": {}
  },
  {
    "operationName": "<string>",
    "query": "<string>",
    "variables": {}
  }
]",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/graphql/batch",
host: [
"{{baseUrl}}"
],
path: [
"graphql",
"batch"
]
},
description: "Perform batched GraphQL query"
},
response: [
{
name: "Successful query (with select).",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "[
  {
    "operationName": "<string>",
    "query": "<string>",
    "variables": {}
  },
  {
    "operationName": "<string>",
    "query": "<string>",
    "variables": {}
  }
]",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/graphql/batch",
host: [
"{{baseUrl}}"
],
path: [
"graphql",
"batch"
]
}
},
status: "OK",
code: 200,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "[
  {
    "data": {
      "elit5": {}
    },
    "errors": [
      {
        "locations": [
          {
            "column": "<long>",
            "line": "<long>"
          },
          {
            "column": "<long>",
            "line": "<long>"
          }
        ],
        "message": "<string>",
        "path": [
          "<string>",
          "<string>"
        ]
      },
      {
        "locations": [
          {
            "column": "<long>",
            "line": "<long>"
          },
          {
            "column": "<long>",
            "line": "<long>"
          }
        ],
        "message": "<string>",
        "path": [
          "<string>",
          "<string>"
        ]
      }
    ]
  },
  {
    "data": {
      "esse_b0": {}
    },
    "errors": [
      {
        "locations": [
          {
            "column": "<long>",
            "line": "<long>"
          },
          {
            "column": "<long>",
            "line": "<long>"
          }
        ],
        "message": "<string>",
        "path": [
          "<string>",
          "<string>"
        ]
      },
      {
        "locations": [
          {
            "column": "<long>",
            "line": "<long>"
          },
          {
            "column": "<long>",
            "line": "<long>"
          }
        ],
        "message": "<string>",
        "path": [
          "<string>",
          "<string>"
        ]
      }
    ]
  }
]"
},
{
name: "Unauthorized or invalid credentials.",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "[
  {
    "operationName": "<string>",
    "query": "<string>",
    "variables": {}
  },
  {
    "operationName": "<string>",
    "query": "<string>",
    "variables": {}
  }
]",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/graphql/batch",
host: [
"{{baseUrl}}"
],
path: [
"graphql",
"batch"
]
}
},
status: "Unauthorized",
code: 401,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Forbidden",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "[
  {
    "operationName": "<string>",
    "query": "<string>",
    "variables": {}
  },
  {
    "operationName": "<string>",
    "query": "<string>",
    "variables": {}
  }
]",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/graphql/batch",
host: [
"{{baseUrl}}"
],
path: [
"graphql",
"batch"
]
}
},
status: "Forbidden",
code: 403,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Request body is well-formed (i.e., syntactically correct), but semantically erroneous. Are you sure the class is defined in the configuration file?",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "[
  {
    "operationName": "<string>",
    "query": "<string>",
    "variables": {}
  },
  {
    "operationName": "<string>",
    "query": "<string>",
    "variables": {}
  }
]",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/graphql/batch",
host: [
"{{baseUrl}}"
],
path: [
"graphql",
"batch"
]
}
},
status: "Unprocessable Entity (WebDAV) (RFC 4918)",
code: 422,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error.",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "[
  {
    "operationName": "<string>",
    "query": "<string>",
    "variables": {}
  },
  {
    "operationName": "<string>",
    "query": "<string>",
    "variables": {}
  }
]",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/graphql/batch",
host: [
"{{baseUrl}}"
],
path: [
"graphql",
"batch"
]
}
},
status: "Internal Server Error",
code: 500,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
}
]
}
]
},
{
name: "Perform a GraphQL query.",
request: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "operationName": "<string>",
  "query": "<string>",
  "variables": {}
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/graphql",
host: [
"{{baseUrl}}"
],
path: [
"graphql"
]
},
description: "Get a response based on a GraphQL query"
},
response: [
{
name: "Successful query (with select).",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "operationName": "<string>",
  "query": "<string>",
  "variables": {}
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/graphql",
host: [
"{{baseUrl}}"
],
path: [
"graphql"
]
}
},
status: "OK",
code: 200,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "data": {
    "cupidatat34": {}
  },
  "errors": [
    {
      "locations": [
        {
          "column": "<long>",
          "line": "<long>"
        },
        {
          "column": "<long>",
          "line": "<long>"
        }
      ],
      "message": "<string>",
      "path": [
        "<string>",
        "<string>"
      ]
    },
    {
      "locations": [
        {
          "column": "<long>",
          "line": "<long>"
        },
        {
          "column": "<long>",
          "line": "<long>"
        }
      ],
      "message": "<string>",
      "path": [
        "<string>",
        "<string>"
      ]
    }
  ]
}"
},
{
name: "Unauthorized or invalid credentials.",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "operationName": "<string>",
  "query": "<string>",
  "variables": {}
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/graphql",
host: [
"{{baseUrl}}"
],
path: [
"graphql"
]
}
},
status: "Unauthorized",
code: 401,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Forbidden",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "operationName": "<string>",
  "query": "<string>",
  "variables": {}
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/graphql",
host: [
"{{baseUrl}}"
],
path: [
"graphql"
]
}
},
status: "Forbidden",
code: 403,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Request body is well-formed (i.e., syntactically correct), but semantically erroneous. Are you sure the class is defined in the configuration file?",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "operationName": "<string>",
  "query": "<string>",
  "variables": {}
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/graphql",
host: [
"{{baseUrl}}"
],
path: [
"graphql"
]
}
},
status: "Unprocessable Entity (WebDAV) (RFC 4918)",
code: 422,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error.",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "operationName": "<string>",
  "query": "<string>",
  "variables": {}
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/graphql",
host: [
"{{baseUrl}}"
],
path: [
"graphql"
]
}
},
status: "Internal Server Error",
code: 500,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
}
]
}
]
},
{
name: "meta",
item: [
{
name: "Get instance metadata.",
request: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/meta",
host: [
"{{baseUrl}}"
],
path: [
"meta"
]
},
description: "Returns meta information about the server. Can be used to provide information to another Weaviate instance that wants to interact with the current instance."
},
response: [
{
name: "Successful response.",
originalRequest: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/meta",
host: [
"{{baseUrl}}"
],
path: [
"meta"
]
}
},
status: "OK",
code: 200,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "hostname": "<string>",
  "version": "<string>",
  "modules": {}
}"
},
{
name: "Unauthorized or invalid credentials.",
originalRequest: {
method: "GET",
header: [ ],
url: {
raw: "{{baseUrl}}/meta",
host: [
"{{baseUrl}}"
],
path: [
"meta"
]
}
},
status: "Unauthorized",
code: 401,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Forbidden",
originalRequest: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/meta",
host: [
"{{baseUrl}}"
],
path: [
"meta"
]
}
},
status: "Forbidden",
code: 403,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error.",
originalRequest: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/meta",
host: [
"{{baseUrl}}"
],
path: [
"meta"
]
}
},
status: "Internal Server Error",
code: 500,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
}
]
}
]
},
{
name: "schema",
item: [
{
name: "{className}",
item: [
{
name: "properties",
item: [
{
name: "Add a property.",
request: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "name": "<string>",
  "dataType": [
    "date[]",
    "int"
  ],
  "description": "<string>",
  "moduleConfig": {
    "<module_name>": {
      "skip": false,
      "vectorizePropertyName": true
    }
  },
  "indexInverted": true,
  "indexFilterable": true,
  "indexSearchable": true,
  "indexRangeFilters": "<boolean>",
  "tokenization": "word",
  "nestedProperties": [
    {
      "name": "<string>",
      "dataType": [
        "object",
        "number"
      ],
      "description": "<string>",
      "indexFilterable": true,
      "indexSearchable": true,
      "indexRangeFilters": "<boolean>",
      "tokenization": "word",
      "nestedProperties": [
        {
          "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
        },
        {
          "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
        }
      ]
    },
    {
      "name": "<string>",
      "dataType": [
        "uuid[]",
        "int"
      ],
      "description": "<string>",
      "indexFilterable": true,
      "indexSearchable": true,
      "indexRangeFilters": "<boolean>",
      "tokenization": "word",
      "nestedProperties": [
        {
          "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
        },
        {
          "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
        }
      ]
    }
  ]
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/schema/:className/properties",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className",
"properties"
],
variable: [
{
key: "className",
value: "<string>",
description: "(Required) "
}
]
},
description: "Add a property to an existing collection. <br/><br/>If possible, we encourage you to create all required properties at collection creation time. Adding a property after collection creation can lead to [some indexing limitations](https://weaviate.io/developers/weaviate/config-refs/schema)."
},
response: [
{
name: "Added the property.",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "name": "<string>",
  "dataType": [
    "date[]",
    "int"
  ],
  "description": "<string>",
  "moduleConfig": {
    "<module_name>": {
      "skip": false,
      "vectorizePropertyName": true
    }
  },
  "indexInverted": true,
  "indexFilterable": true,
  "indexSearchable": true,
  "indexRangeFilters": "<boolean>",
  "tokenization": "word",
  "nestedProperties": [
    {
      "name": "<string>",
      "dataType": [
        "object",
        "number"
      ],
      "description": "<string>",
      "indexFilterable": true,
      "indexSearchable": true,
      "indexRangeFilters": "<boolean>",
      "tokenization": "word",
      "nestedProperties": [
        {
          "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
        },
        {
          "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
        }
      ]
    },
    {
      "name": "<string>",
      "dataType": [
        "uuid[]",
        "int"
      ],
      "description": "<string>",
      "indexFilterable": true,
      "indexSearchable": true,
      "indexRangeFilters": "<boolean>",
      "tokenization": "word",
      "nestedProperties": [
        {
          "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
        },
        {
          "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
        }
      ]
    }
  ]
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/schema/:className/properties",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className",
"properties"
],
variable: [
{
key: "className"
}
]
}
},
status: "OK",
code: 200,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "name": "<string>",
  "dataType": [
    "date[]",
    "int"
  ],
  "description": "<string>",
  "moduleConfig": {
    "<module_name>": {
      "skip": false,
      "vectorizePropertyName": true
    }
  },
  "indexInverted": true,
  "indexFilterable": true,
  "indexSearchable": true,
  "indexRangeFilters": "<boolean>",
  "tokenization": "word",
  "nestedProperties": [
    {
      "name": "<string>",
      "dataType": [
        "object",
        "number"
      ],
      "description": "<string>",
      "indexFilterable": true,
      "indexSearchable": true,
      "indexRangeFilters": "<boolean>",
      "tokenization": "word",
      "nestedProperties": [
        {
          "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
        },
        {
          "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
        }
      ]
    },
    {
      "name": "<string>",
      "dataType": [
        "uuid[]",
        "int"
      ],
      "description": "<string>",
      "indexFilterable": true,
      "indexSearchable": true,
      "indexRangeFilters": "<boolean>",
      "tokenization": "word",
      "nestedProperties": [
        {
          "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
        },
        {
          "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
        }
      ]
    }
  ]
}"
},
{
name: "Unauthorized or invalid credentials.",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "name": "<string>",
  "dataType": [
    "date[]",
    "int"
  ],
  "description": "<string>",
  "moduleConfig": {
    "<module_name>": {
      "skip": false,
      "vectorizePropertyName": true
    }
  },
  "indexInverted": true,
  "indexFilterable": true,
  "indexSearchable": true,
  "indexRangeFilters": "<boolean>",
  "tokenization": "word",
  "nestedProperties": [
    {
      "name": "<string>",
      "dataType": [
        "object",
        "number"
      ],
      "description": "<string>",
      "indexFilterable": true,
      "indexSearchable": true,
      "indexRangeFilters": "<boolean>",
      "tokenization": "word",
      "nestedProperties": [
        {
          "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
        },
        {
          "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
        }
      ]
    },
    {
      "name": "<string>",
      "dataType": [
        "uuid[]",
        "int"
      ],
      "description": "<string>",
      "indexFilterable": true,
      "indexSearchable": true,
      "indexRangeFilters": "<boolean>",
      "tokenization": "word",
      "nestedProperties": [
        {
          "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
        },
        {
          "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
        }
      ]
    }
  ]
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/schema/:className/properties",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className",
"properties"
],
variable: [
{
key: "className"
}
]
}
},
status: "Unauthorized",
code: 401,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Forbidden",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "name": "<string>",
  "dataType": [
    "date[]",
    "int"
  ],
  "description": "<string>",
  "moduleConfig": {
    "<module_name>": {
      "skip": false,
      "vectorizePropertyName": true
    }
  },
  "indexInverted": true,
  "indexFilterable": true,
  "indexSearchable": true,
  "indexRangeFilters": "<boolean>",
  "tokenization": "word",
  "nestedProperties": [
    {
      "name": "<string>",
      "dataType": [
        "object",
        "number"
      ],
      "description": "<string>",
      "indexFilterable": true,
      "indexSearchable": true,
      "indexRangeFilters": "<boolean>",
      "tokenization": "word",
      "nestedProperties": [
        {
          "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
        },
        {
          "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
        }
      ]
    },
    {
      "name": "<string>",
      "dataType": [
        "uuid[]",
        "int"
      ],
      "description": "<string>",
      "indexFilterable": true,
      "indexSearchable": true,
      "indexRangeFilters": "<boolean>",
      "tokenization": "word",
      "nestedProperties": [
        {
          "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
        },
        {
          "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
        }
      ]
    }
  ]
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/schema/:className/properties",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className",
"properties"
],
variable: [
{
key: "className"
}
]
}
},
status: "Forbidden",
code: 403,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Invalid property.",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "name": "<string>",
  "dataType": [
    "date[]",
    "int"
  ],
  "description": "<string>",
  "moduleConfig": {
    "<module_name>": {
      "skip": false,
      "vectorizePropertyName": true
    }
  },
  "indexInverted": true,
  "indexFilterable": true,
  "indexSearchable": true,
  "indexRangeFilters": "<boolean>",
  "tokenization": "word",
  "nestedProperties": [
    {
      "name": "<string>",
      "dataType": [
        "object",
        "number"
      ],
      "description": "<string>",
      "indexFilterable": true,
      "indexSearchable": true,
      "indexRangeFilters": "<boolean>",
      "tokenization": "word",
      "nestedProperties": [
        {
          "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
        },
        {
          "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
        }
      ]
    },
    {
      "name": "<string>",
      "dataType": [
        "uuid[]",
        "int"
      ],
      "description": "<string>",
      "indexFilterable": true,
      "indexSearchable": true,
      "indexRangeFilters": "<boolean>",
      "tokenization": "word",
      "nestedProperties": [
        {
          "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
        },
        {
          "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
        }
      ]
    }
  ]
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/schema/:className/properties",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className",
"properties"
],
variable: [
{
key: "className"
}
]
}
},
status: "Unprocessable Entity (WebDAV) (RFC 4918)",
code: 422,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error.",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "name": "<string>",
  "dataType": [
    "date[]",
    "int"
  ],
  "description": "<string>",
  "moduleConfig": {
    "<module_name>": {
      "skip": false,
      "vectorizePropertyName": true
    }
  },
  "indexInverted": true,
  "indexFilterable": true,
  "indexSearchable": true,
  "indexRangeFilters": "<boolean>",
  "tokenization": "word",
  "nestedProperties": [
    {
      "name": "<string>",
      "dataType": [
        "object",
        "number"
      ],
      "description": "<string>",
      "indexFilterable": true,
      "indexSearchable": true,
      "indexRangeFilters": "<boolean>",
      "tokenization": "word",
      "nestedProperties": [
        {
          "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
        },
        {
          "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
        }
      ]
    },
    {
      "name": "<string>",
      "dataType": [
        "uuid[]",
        "int"
      ],
      "description": "<string>",
      "indexFilterable": true,
      "indexSearchable": true,
      "indexRangeFilters": "<boolean>",
      "tokenization": "word",
      "nestedProperties": [
        {
          "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
        },
        {
          "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
        }
      ]
    }
  ]
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/schema/:className/properties",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className",
"properties"
],
variable: [
{
key: "className"
}
]
}
},
status: "Internal Server Error",
code: 500,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
}
]
}
]
},
{
name: "shards",
item: [
{
name: "{shardName}",
item: [
{
name: "Update a shard status.",
request: {
method: "PUT",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "status": "<string>"
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/schema/:className/shards/:shardName",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className",
"shards",
":shardName"
],
variable: [
{
key: "className",
value: "<string>",
description: "(Required) "
},
{
key: "shardName",
value: "<string>",
description: "(Required) "
}
]
},
description: "Update a shard status for a collection. For example, a shard may have been marked as `READONLY` because its disk was full. After providing more disk space, use this endpoint to set the shard status to `READY` again. There is also a convenience function in each client to set the status of all shards of a collection."
},
response: [
{
name: "Shard status was updated successfully",
originalRequest: {
method: "PUT",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "status": "<string>"
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/schema/:className/shards/:shardName",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className",
"shards",
":shardName"
],
variable: [
{
key: "className"
},
{
key: "shardName"
}
]
}
},
status: "OK",
code: 200,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "status": "<string>"
}"
},
{
name: "Unauthorized or invalid credentials.",
originalRequest: {
method: "PUT",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "status": "<string>"
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/schema/:className/shards/:shardName",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className",
"shards",
":shardName"
],
variable: [
{
key: "className"
},
{
key: "shardName"
}
]
}
},
status: "Unauthorized",
code: 401,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Forbidden",
originalRequest: {
method: "PUT",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "status": "<string>"
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/schema/:className/shards/:shardName",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className",
"shards",
":shardName"
],
variable: [
{
key: "className"
},
{
key: "shardName"
}
]
}
},
status: "Forbidden",
code: 403,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Shard to be updated does not exist",
originalRequest: {
method: "PUT",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "status": "<string>"
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/schema/:className/shards/:shardName",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className",
"shards",
":shardName"
],
variable: [
{
key: "className"
},
{
key: "shardName"
}
]
}
},
status: "Not Found",
code: 404,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Invalid update attempt",
originalRequest: {
method: "PUT",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "status": "<string>"
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/schema/:className/shards/:shardName",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className",
"shards",
":shardName"
],
variable: [
{
key: "className"
},
{
key: "shardName"
}
]
}
},
status: "Unprocessable Entity (WebDAV) (RFC 4918)",
code: 422,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error.",
originalRequest: {
method: "PUT",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "status": "<string>"
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/schema/:className/shards/:shardName",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className",
"shards",
":shardName"
],
variable: [
{
key: "className"
},
{
key: "shardName"
}
]
}
},
status: "Internal Server Error",
code: 500,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
}
]
}
]
},
{
name: "Get the shard status",
request: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/schema/:className/shards?tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className",
"shards"
],
query: [
{
key: "tenant",
value: "<string>"
}
],
variable: [
{
key: "className",
value: "<string>",
description: "(Required) "
}
]
},
description: "Get the status of every shard in the cluster."
},
response: [
{
name: "Found the status of the shards, returned as body",
originalRequest: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/schema/:className/shards?tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className",
"shards"
],
query: [
{
key: "tenant",
value: "<string>"
}
],
variable: [
{
key: "className"
}
]
}
},
status: "OK",
code: 200,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "[
  {
    "name": "<string>",
    "status": "<string>",
    "vectorQueueSize": "<integer>"
  },
  {
    "name": "<string>",
    "status": "<string>",
    "vectorQueueSize": "<integer>"
  }
]"
},
{
name: "Unauthorized or invalid credentials.",
originalRequest: {
method: "GET",
header: [ ],
url: {
raw: "{{baseUrl}}/schema/:className/shards?tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className",
"shards"
],
query: [
{
key: "tenant",
value: "<string>"
}
],
variable: [
{
key: "className"
}
]
}
},
status: "Unauthorized",
code: 401,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Forbidden",
originalRequest: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/schema/:className/shards?tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className",
"shards"
],
query: [
{
key: "tenant",
value: "<string>"
}
],
variable: [
{
key: "className"
}
]
}
},
status: "Forbidden",
code: 403,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "This class does not exist",
originalRequest: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/schema/:className/shards?tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className",
"shards"
],
query: [
{
key: "tenant",
value: "<string>"
}
],
variable: [
{
key: "className"
}
]
}
},
status: "Not Found",
code: 404,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error.",
originalRequest: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/schema/:className/shards?tenant=<string>",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className",
"shards"
],
query: [
{
key: "tenant",
value: "<string>"
}
],
variable: [
{
key: "className"
}
]
}
},
status: "Internal Server Error",
code: 500,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
}
]
}
]
},
{
name: "tenants",
item: [
{
name: "{tenantName}",
item: [
{
name: "Check whether a tenant exists",
request: {
method: "HEAD",
header: [
{
key: "consistency",
value: "true",
description: "If consistency is true, the request will be proxied to the leader to ensure strong schema consistency"
},
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/schema/:className/tenants/:tenantName",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className",
"tenants",
":tenantName"
],
variable: [
{
key: "className",
value: "<string>",
description: "(Required) "
},
{
key: "tenantName",
value: "<string>",
description: "(Required) "
}
]
},
description: "Check if a tenant exists for a specific class"
},
response: [
{
name: "The tenant exists in the specified class",
originalRequest: {
method: "HEAD",
header: [
{
key: "consistency",
value: "true",
description: "If consistency is true, the request will be proxied to the leader to ensure strong schema consistency"
}
],
url: {
raw: "{{baseUrl}}/schema/:className/tenants/:tenantName",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className",
"tenants",
":tenantName"
],
variable: [
{
key: "className"
},
{
key: "tenantName"
}
]
}
},
status: "OK",
code: 200,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Unauthorized or invalid credentials.",
originalRequest: {
method: "HEAD",
header: [
{
key: "consistency",
value: "true",
description: "If consistency is true, the request will be proxied to the leader to ensure strong schema consistency"
}
],
url: {
raw: "{{baseUrl}}/schema/:className/tenants/:tenantName",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className",
"tenants",
":tenantName"
],
variable: [
{
key: "className"
},
{
key: "tenantName"
}
]
}
},
status: "Unauthorized",
code: 401,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Forbidden",
originalRequest: {
method: "HEAD",
header: [
{
key: "consistency",
value: "true",
description: "If consistency is true, the request will be proxied to the leader to ensure strong schema consistency"
},
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/schema/:className/tenants/:tenantName",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className",
"tenants",
":tenantName"
],
variable: [
{
key: "className"
},
{
key: "tenantName"
}
]
}
},
status: "Forbidden",
code: 403,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "The tenant not found",
originalRequest: {
method: "HEAD",
header: [
{
key: "consistency",
value: "true",
description: "If consistency is true, the request will be proxied to the leader to ensure strong schema consistency"
}
],
url: {
raw: "{{baseUrl}}/schema/:className/tenants/:tenantName",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className",
"tenants",
":tenantName"
],
variable: [
{
key: "className"
},
{
key: "tenantName"
}
]
}
},
status: "Not Found",
code: 404,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Invalid Tenant class",
originalRequest: {
method: "HEAD",
header: [
{
key: "consistency",
value: "true",
description: "If consistency is true, the request will be proxied to the leader to ensure strong schema consistency"
},
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/schema/:className/tenants/:tenantName",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className",
"tenants",
":tenantName"
],
variable: [
{
key: "className"
},
{
key: "tenantName"
}
]
}
},
status: "Unprocessable Entity (WebDAV) (RFC 4918)",
code: 422,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error.",
originalRequest: {
method: "HEAD",
header: [
{
key: "consistency",
value: "true",
description: "If consistency is true, the request will be proxied to the leader to ensure strong schema consistency"
},
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/schema/:className/tenants/:tenantName",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className",
"tenants",
":tenantName"
],
variable: [
{
key: "className"
},
{
key: "tenantName"
}
]
}
},
status: "Internal Server Error",
code: 500,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
}
]
}
]
},
{
name: "Create a new tenant",
request: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "[
  {
    "name": "<string>",
    "activityStatus": "ONLOADING"
  },
  {
    "name": "<string>",
    "activityStatus": "COLD"
  }
]",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/schema/:className/tenants",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className",
"tenants"
],
variable: [
{
key: "className",
value: "<string>",
description: "(Required) "
}
]
},
description: "Create a new tenant for a collection. Multi-tenancy must be enabled in the collection definition."
},
response: [
{
name: "Added new tenants to the specified class",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "[
  {
    "name": "<string>",
    "activityStatus": "ONLOADING"
  },
  {
    "name": "<string>",
    "activityStatus": "COLD"
  }
]",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/schema/:className/tenants",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className",
"tenants"
],
variable: [
{
key: "className"
}
]
}
},
status: "OK",
code: 200,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "[
  {
    "name": "<string>",
    "activityStatus": "ONLOADING"
  },
  {
    "name": "<string>",
    "activityStatus": "COLD"
  }
]"
},
{
name: "Unauthorized or invalid credentials.",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "[
  {
    "name": "<string>",
    "activityStatus": "ONLOADING"
  },
  {
    "name": "<string>",
    "activityStatus": "COLD"
  }
]",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/schema/:className/tenants",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className",
"tenants"
],
variable: [
{
key: "className"
}
]
}
},
status: "Unauthorized",
code: 401,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Forbidden",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "[
  {
    "name": "<string>",
    "activityStatus": "ONLOADING"
  },
  {
    "name": "<string>",
    "activityStatus": "COLD"
  }
]",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/schema/:className/tenants",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className",
"tenants"
],
variable: [
{
key: "className"
}
]
}
},
status: "Forbidden",
code: 403,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Invalid Tenant class",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "[
  {
    "name": "<string>",
    "activityStatus": "ONLOADING"
  },
  {
    "name": "<string>",
    "activityStatus": "COLD"
  }
]",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/schema/:className/tenants",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className",
"tenants"
],
variable: [
{
key: "className"
}
]
}
},
status: "Unprocessable Entity (WebDAV) (RFC 4918)",
code: 422,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error.",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "[
  {
    "name": "<string>",
    "activityStatus": "ONLOADING"
  },
  {
    "name": "<string>",
    "activityStatus": "COLD"
  }
]",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/schema/:className/tenants",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className",
"tenants"
],
variable: [
{
key: "className"
}
]
}
},
status: "Internal Server Error",
code: 500,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
}
]
},
{
name: "Update a tenant.",
request: {
method: "PUT",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "[
  {
    "name": "<string>",
    "activityStatus": "ONLOADING"
  },
  {
    "name": "<string>",
    "activityStatus": "COLD"
  }
]",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/schema/:className/tenants",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className",
"tenants"
],
variable: [
{
key: "className",
value: "<string>",
description: "(Required) "
}
]
},
description: "Update a tenant for a collection"
},
response: [
{
name: "Updated tenants of the specified class",
originalRequest: {
method: "PUT",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "[
  {
    "name": "<string>",
    "activityStatus": "ONLOADING"
  },
  {
    "name": "<string>",
    "activityStatus": "COLD"
  }
]",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/schema/:className/tenants",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className",
"tenants"
],
variable: [
{
key: "className"
}
]
}
},
status: "OK",
code: 200,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "[
  {
    "name": "<string>",
    "activityStatus": "ONLOADING"
  },
  {
    "name": "<string>",
    "activityStatus": "COLD"
  }
]"
},
{
name: "Unauthorized or invalid credentials.",
originalRequest: {
method: "PUT",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "[
  {
    "name": "<string>",
    "activityStatus": "ONLOADING"
  },
  {
    "name": "<string>",
    "activityStatus": "COLD"
  }
]",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/schema/:className/tenants",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className",
"tenants"
],
variable: [
{
key: "className"
}
]
}
},
status: "Unauthorized",
code: 401,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Forbidden",
originalRequest: {
method: "PUT",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "[
  {
    "name": "<string>",
    "activityStatus": "ONLOADING"
  },
  {
    "name": "<string>",
    "activityStatus": "COLD"
  }
]",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/schema/:className/tenants",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className",
"tenants"
],
variable: [
{
key: "className"
}
]
}
},
status: "Forbidden",
code: 403,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Invalid Tenant class",
originalRequest: {
method: "PUT",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "[
  {
    "name": "<string>",
    "activityStatus": "ONLOADING"
  },
  {
    "name": "<string>",
    "activityStatus": "COLD"
  }
]",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/schema/:className/tenants",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className",
"tenants"
],
variable: [
{
key: "className"
}
]
}
},
status: "Unprocessable Entity (WebDAV) (RFC 4918)",
code: 422,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error.",
originalRequest: {
method: "PUT",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "[
  {
    "name": "<string>",
    "activityStatus": "ONLOADING"
  },
  {
    "name": "<string>",
    "activityStatus": "COLD"
  }
]",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/schema/:className/tenants",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className",
"tenants"
],
variable: [
{
key: "className"
}
]
}
},
status: "Internal Server Error",
code: 500,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
}
]
},
{
name: "Delete tenant(s).",
request: {
method: "DELETE",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "[
  "<string>",
  "<string>"
]",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/schema/:className/tenants",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className",
"tenants"
],
variable: [
{
key: "className",
value: "<string>",
description: "(Required) "
}
]
},
description: "Delete tenants from a collection"
},
response: [
{
name: "Deleted tenants from specified class.",
originalRequest: {
method: "DELETE",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "[
  "<string>",
  "<string>"
]",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/schema/:className/tenants",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className",
"tenants"
],
variable: [
{
key: "className"
}
]
}
},
status: "OK",
code: 200,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Unauthorized or invalid credentials.",
originalRequest: {
method: "DELETE",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "[
  "<string>",
  "<string>"
]",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/schema/:className/tenants",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className",
"tenants"
],
variable: [
{
key: "className"
}
]
}
},
status: "Unauthorized",
code: 401,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Forbidden",
originalRequest: {
method: "DELETE",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "[
  "<string>",
  "<string>"
]",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/schema/:className/tenants",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className",
"tenants"
],
variable: [
{
key: "className"
}
]
}
},
status: "Forbidden",
code: 403,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Invalid Tenant class",
originalRequest: {
method: "DELETE",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "[
  "<string>",
  "<string>"
]",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/schema/:className/tenants",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className",
"tenants"
],
variable: [
{
key: "className"
}
]
}
},
status: "Unprocessable Entity (WebDAV) (RFC 4918)",
code: 422,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error.",
originalRequest: {
method: "DELETE",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "[
  "<string>",
  "<string>"
]",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/schema/:className/tenants",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className",
"tenants"
],
variable: [
{
key: "className"
}
]
}
},
status: "Internal Server Error",
code: 500,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
}
]
},
{
name: "Get the list of tenants.",
request: {
method: "GET",
header: [
{
key: "consistency",
value: "true",
description: "If consistency is true, the request will be proxied to the leader to ensure strong schema consistency"
},
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/schema/:className/tenants",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className",
"tenants"
],
variable: [
{
key: "className",
value: "<string>",
description: "(Required) "
}
]
},
description: "Get all tenants from a collection."
},
response: [
{
name: "tenants from specified class.",
originalRequest: {
method: "GET",
header: [
{
key: "consistency",
value: "true",
description: "If consistency is true, the request will be proxied to the leader to ensure strong schema consistency"
},
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/schema/:className/tenants",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className",
"tenants"
],
variable: [
{
key: "className"
}
]
}
},
status: "OK",
code: 200,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "[
  {
    "name": "<string>",
    "activityStatus": "ONLOADING"
  },
  {
    "name": "<string>",
    "activityStatus": "COLD"
  }
]"
},
{
name: "Unauthorized or invalid credentials.",
originalRequest: {
method: "GET",
header: [
{
key: "consistency",
value: "true",
description: "If consistency is true, the request will be proxied to the leader to ensure strong schema consistency"
}
],
url: {
raw: "{{baseUrl}}/schema/:className/tenants",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className",
"tenants"
],
variable: [
{
key: "className"
}
]
}
},
status: "Unauthorized",
code: 401,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Forbidden",
originalRequest: {
method: "GET",
header: [
{
key: "consistency",
value: "true",
description: "If consistency is true, the request will be proxied to the leader to ensure strong schema consistency"
},
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/schema/:className/tenants",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className",
"tenants"
],
variable: [
{
key: "className"
}
]
}
},
status: "Forbidden",
code: 403,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Invalid Tenant class",
originalRequest: {
method: "GET",
header: [
{
key: "consistency",
value: "true",
description: "If consistency is true, the request will be proxied to the leader to ensure strong schema consistency"
},
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/schema/:className/tenants",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className",
"tenants"
],
variable: [
{
key: "className"
}
]
}
},
status: "Unprocessable Entity (WebDAV) (RFC 4918)",
code: 422,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error.",
originalRequest: {
method: "GET",
header: [
{
key: "consistency",
value: "true",
description: "If consistency is true, the request will be proxied to the leader to ensure strong schema consistency"
},
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/schema/:className/tenants",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className",
"tenants"
],
variable: [
{
key: "className"
}
]
}
},
status: "Internal Server Error",
code: 500,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
}
]
}
]
},
{
name: "Get a single collection schema.",
request: {
method: "GET",
header: [
{
key: "consistency",
value: "true",
description: "If consistency is true, the request will be proxied to the leader to ensure strong schema consistency"
},
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/schema/:className",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className"
],
variable: [
{
key: "className",
value: "<string>",
description: "(Required) "
}
]
}
},
response: [
{
name: "Found the Class, returned as body",
originalRequest: {
method: "GET",
header: [
{
key: "consistency",
value: "true",
description: "If consistency is true, the request will be proxied to the leader to ensure strong schema consistency"
},
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/schema/:className",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className"
],
variable: [
{
key: "className"
}
]
}
},
status: "OK",
code: 200,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "class": "<string>",
  "vectorConfig": {
    "<vector_name>": {
      "vectorizer": "none",
      "vectorIndexType": "hnsw",
      "vectorIndexConfig": {}
    }
  },
  "vectorIndexType": "hnsw",
  "vectorIndexConfig": {},
  "shardingConfig": {
    "desiredCount": "<integer>",
    "virtualPerPhysical": 128
  },
  "replicationConfig": {
    "factor": 1,
    "asyncEnabled": "<boolean>"
  },
  "invertedIndexConfig": {
    "cleanupIntervalSeconds": 60,
    "bm25": {
      "k1": 1.2,
      "b": 0.75
    },
    "stopwords": {
      "preset": "en"
    },
    "indexTimestamps": false,
    "indexNullState": false,
    "indexPropertyLength": false
  },
  "multiTenancyConfig": {
    "enabled": false,
    "autoTenantCreation": "<boolean>",
    "autoTenantActivation": "<boolean>"
  },
  "vectorizer": "<vectorizer_module_name>",
  "moduleConfig": {
    "<module_name>": {
      "vectorizeClassName": true
    }
  },
  "description": "<string>",
  "properties": [
    {
      "name": "<string>",
      "dataType": [
        "uuid",
        "string[]"
      ],
      "description": "<string>",
      "moduleConfig": {
        "<module_name>": {
          "skip": false,
          "vectorizePropertyName": true
        }
      },
      "indexInverted": true,
      "indexFilterable": true,
      "indexSearchable": true,
      "indexRangeFilters": "<boolean>",
      "tokenization": "word",
      "nestedProperties": [
        {
          "name": "<string>",
          "dataType": [
            "number",
            "blob"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        },
        {
          "name": "<string>",
          "dataType": [
            "date",
            "<cross_reference>"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        }
      ]
    },
    {
      "name": "<string>",
      "dataType": [
        "object",
        "number[]"
      ],
      "description": "<string>",
      "moduleConfig": {
        "<module_name>": {
          "skip": false,
          "vectorizePropertyName": true
        }
      },
      "indexInverted": true,
      "indexFilterable": true,
      "indexSearchable": true,
      "indexRangeFilters": "<boolean>",
      "tokenization": "word",
      "nestedProperties": [
        {
          "name": "<string>",
          "dataType": [
            "<cross_reference>",
            "blob"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        },
        {
          "name": "<string>",
          "dataType": [
            "<cross_reference>",
            "string[]"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        }
      ]
    }
  ]
}"
},
{
name: "Unauthorized or invalid credentials.",
originalRequest: {
method: "GET",
header: [
{
key: "consistency",
value: "true",
description: "If consistency is true, the request will be proxied to the leader to ensure strong schema consistency"
}
],
url: {
raw: "{{baseUrl}}/schema/:className",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className"
],
variable: [
{
key: "className"
}
]
}
},
status: "Unauthorized",
code: 401,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Forbidden",
originalRequest: {
method: "GET",
header: [
{
key: "consistency",
value: "true",
description: "If consistency is true, the request will be proxied to the leader to ensure strong schema consistency"
},
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/schema/:className",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className"
],
variable: [
{
key: "className"
}
]
}
},
status: "Forbidden",
code: 403,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "This class does not exist",
originalRequest: {
method: "GET",
header: [
{
key: "consistency",
value: "true",
description: "If consistency is true, the request will be proxied to the leader to ensure strong schema consistency"
}
],
url: {
raw: "{{baseUrl}}/schema/:className",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className"
],
variable: [
{
key: "className"
}
]
}
},
status: "Not Found",
code: 404,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error.",
originalRequest: {
method: "GET",
header: [
{
key: "consistency",
value: "true",
description: "If consistency is true, the request will be proxied to the leader to ensure strong schema consistency"
},
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/schema/:className",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className"
],
variable: [
{
key: "className"
}
]
}
},
status: "Internal Server Error",
code: 500,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
}
]
},
{
name: "Remove a collection (and its data).",
request: {
method: "DELETE",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/schema/:className",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className"
],
variable: [
{
key: "className",
value: "<string>",
description: "(Required) "
}
]
},
description: "Remove a collection from the schema. This will also delete all the objects in the collection."
},
response: [
{
name: "Removed the Object class from the schema.",
originalRequest: {
method: "DELETE",
header: [ ],
url: {
raw: "{{baseUrl}}/schema/:className",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className"
],
variable: [
{
key: "className"
}
]
}
},
status: "OK",
code: 200,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Could not delete the Object class.",
originalRequest: {
method: "DELETE",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/schema/:className",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className"
],
variable: [
{
key: "className"
}
]
}
},
status: "Bad Request",
code: 400,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Unauthorized or invalid credentials.",
originalRequest: {
method: "DELETE",
header: [ ],
url: {
raw: "{{baseUrl}}/schema/:className",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className"
],
variable: [
{
key: "className"
}
]
}
},
status: "Unauthorized",
code: 401,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Forbidden",
originalRequest: {
method: "DELETE",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/schema/:className",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className"
],
variable: [
{
key: "className"
}
]
}
},
status: "Forbidden",
code: 403,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error.",
originalRequest: {
method: "DELETE",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/schema/:className",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className"
],
variable: [
{
key: "className"
}
]
}
},
status: "Internal Server Error",
code: 500,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
}
]
},
{
name: "Update an existing collection.",
request: {
method: "PUT",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<string>",
  "vectorConfig": {
    "<vector_name>": {
      "vectorizer": "none",
      "vectorIndexType": "hnsw",
      "vectorIndexConfig": {}
    }
  },
  "vectorIndexType": "hnsw",
  "vectorIndexConfig": {},
  "shardingConfig": {
    "desiredCount": "<integer>",
    "virtualPerPhysical": 128
  },
  "replicationConfig": {
    "factor": 1,
    "asyncEnabled": "<boolean>"
  },
  "invertedIndexConfig": {
    "cleanupIntervalSeconds": 60,
    "bm25": {
      "k1": 1.2,
      "b": 0.75
    },
    "stopwords": {
      "preset": "en"
    },
    "indexTimestamps": false,
    "indexNullState": false,
    "indexPropertyLength": false
  },
  "multiTenancyConfig": {
    "enabled": false,
    "autoTenantCreation": "<boolean>",
    "autoTenantActivation": "<boolean>"
  },
  "vectorizer": "<vectorizer_module_name>",
  "moduleConfig": {
    "<module_name>": {
      "vectorizeClassName": true
    }
  },
  "description": "<string>",
  "properties": [
    {
      "name": "<string>",
      "dataType": [
        "uuid",
        "string[]"
      ],
      "description": "<string>",
      "moduleConfig": {
        "<module_name>": {
          "skip": false,
          "vectorizePropertyName": true
        }
      },
      "indexInverted": true,
      "indexFilterable": true,
      "indexSearchable": true,
      "indexRangeFilters": "<boolean>",
      "tokenization": "word",
      "nestedProperties": [
        {
          "name": "<string>",
          "dataType": [
            "number",
            "blob"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        },
        {
          "name": "<string>",
          "dataType": [
            "date",
            "<cross_reference>"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        }
      ]
    },
    {
      "name": "<string>",
      "dataType": [
        "object",
        "number[]"
      ],
      "description": "<string>",
      "moduleConfig": {
        "<module_name>": {
          "skip": false,
          "vectorizePropertyName": true
        }
      },
      "indexInverted": true,
      "indexFilterable": true,
      "indexSearchable": true,
      "indexRangeFilters": "<boolean>",
      "tokenization": "word",
      "nestedProperties": [
        {
          "name": "<string>",
          "dataType": [
            "<cross_reference>",
            "blob"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        },
        {
          "name": "<string>",
          "dataType": [
            "<cross_reference>",
            "string[]"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        }
      ]
    }
  ]
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/schema/:className",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className"
],
variable: [
{
key: "className",
value: "<string>",
description: "(Required) "
}
]
},
description: "Alter an existing collection definition. <br/><br/>Note that not all settings are mutable ([see this list](https://weaviate.io/developers/weaviate/config-refs/schema#mutability)). To update any other (i.e. immutable) setting, you need to delete the collection, re-create it with the correct setting and then re-import the data. <br/><br/>This endpoint cannot be used to modify properties. Instead use POST /v1/schema/{className}/properties. A typical use case for this endpoint is to update a index configuration, such as `vectorIndexConfig/dynamicEfFactor`. <br/><br/>You should attach a body to this PUT request with the entire new configuration of the collection."
},
response: [
{
name: "Class was updated successfully",
originalRequest: {
method: "PUT",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<string>",
  "vectorConfig": {
    "<vector_name>": {
      "vectorizer": "none",
      "vectorIndexType": "hnsw",
      "vectorIndexConfig": {}
    }
  },
  "vectorIndexType": "hnsw",
  "vectorIndexConfig": {},
  "shardingConfig": {
    "desiredCount": "<integer>",
    "virtualPerPhysical": 128
  },
  "replicationConfig": {
    "factor": 1,
    "asyncEnabled": "<boolean>"
  },
  "invertedIndexConfig": {
    "cleanupIntervalSeconds": 60,
    "bm25": {
      "k1": 1.2,
      "b": 0.75
    },
    "stopwords": {
      "preset": "en"
    },
    "indexTimestamps": false,
    "indexNullState": false,
    "indexPropertyLength": false
  },
  "multiTenancyConfig": {
    "enabled": false,
    "autoTenantCreation": "<boolean>",
    "autoTenantActivation": "<boolean>"
  },
  "vectorizer": "<vectorizer_module_name>",
  "moduleConfig": {
    "<module_name>": {
      "vectorizeClassName": true
    }
  },
  "description": "<string>",
  "properties": [
    {
      "name": "<string>",
      "dataType": [
        "uuid",
        "string[]"
      ],
      "description": "<string>",
      "moduleConfig": {
        "<module_name>": {
          "skip": false,
          "vectorizePropertyName": true
        }
      },
      "indexInverted": true,
      "indexFilterable": true,
      "indexSearchable": true,
      "indexRangeFilters": "<boolean>",
      "tokenization": "word",
      "nestedProperties": [
        {
          "name": "<string>",
          "dataType": [
            "number",
            "blob"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        },
        {
          "name": "<string>",
          "dataType": [
            "date",
            "<cross_reference>"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        }
      ]
    },
    {
      "name": "<string>",
      "dataType": [
        "object",
        "number[]"
      ],
      "description": "<string>",
      "moduleConfig": {
        "<module_name>": {
          "skip": false,
          "vectorizePropertyName": true
        }
      },
      "indexInverted": true,
      "indexFilterable": true,
      "indexSearchable": true,
      "indexRangeFilters": "<boolean>",
      "tokenization": "word",
      "nestedProperties": [
        {
          "name": "<string>",
          "dataType": [
            "<cross_reference>",
            "blob"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        },
        {
          "name": "<string>",
          "dataType": [
            "<cross_reference>",
            "string[]"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        }
      ]
    }
  ]
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/schema/:className",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className"
],
variable: [
{
key: "className"
}
]
}
},
status: "OK",
code: 200,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "class": "<string>",
  "vectorConfig": {
    "<vector_name>": {
      "vectorizer": "none",
      "vectorIndexType": "hnsw",
      "vectorIndexConfig": {}
    }
  },
  "vectorIndexType": "hnsw",
  "vectorIndexConfig": {},
  "shardingConfig": {
    "desiredCount": "<integer>",
    "virtualPerPhysical": 128
  },
  "replicationConfig": {
    "factor": 1,
    "asyncEnabled": "<boolean>"
  },
  "invertedIndexConfig": {
    "cleanupIntervalSeconds": 60,
    "bm25": {
      "k1": 1.2,
      "b": 0.75
    },
    "stopwords": {
      "preset": "en"
    },
    "indexTimestamps": false,
    "indexNullState": false,
    "indexPropertyLength": false
  },
  "multiTenancyConfig": {
    "enabled": false,
    "autoTenantCreation": "<boolean>",
    "autoTenantActivation": "<boolean>"
  },
  "vectorizer": "<vectorizer_module_name>",
  "moduleConfig": {
    "<module_name>": {
      "vectorizeClassName": true
    }
  },
  "description": "<string>",
  "properties": [
    {
      "name": "<string>",
      "dataType": [
        "uuid",
        "string[]"
      ],
      "description": "<string>",
      "moduleConfig": {
        "<module_name>": {
          "skip": false,
          "vectorizePropertyName": true
        }
      },
      "indexInverted": true,
      "indexFilterable": true,
      "indexSearchable": true,
      "indexRangeFilters": "<boolean>",
      "tokenization": "word",
      "nestedProperties": [
        {
          "name": "<string>",
          "dataType": [
            "number",
            "blob"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        },
        {
          "name": "<string>",
          "dataType": [
            "date",
            "<cross_reference>"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        }
      ]
    },
    {
      "name": "<string>",
      "dataType": [
        "object",
        "number[]"
      ],
      "description": "<string>",
      "moduleConfig": {
        "<module_name>": {
          "skip": false,
          "vectorizePropertyName": true
        }
      },
      "indexInverted": true,
      "indexFilterable": true,
      "indexSearchable": true,
      "indexRangeFilters": "<boolean>",
      "tokenization": "word",
      "nestedProperties": [
        {
          "name": "<string>",
          "dataType": [
            "<cross_reference>",
            "blob"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        },
        {
          "name": "<string>",
          "dataType": [
            "<cross_reference>",
            "string[]"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        }
      ]
    }
  ]
}"
},
{
name: "Unauthorized or invalid credentials.",
originalRequest: {
method: "PUT",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<string>",
  "vectorConfig": {
    "<vector_name>": {
      "vectorizer": "none",
      "vectorIndexType": "hnsw",
      "vectorIndexConfig": {}
    }
  },
  "vectorIndexType": "hnsw",
  "vectorIndexConfig": {},
  "shardingConfig": {
    "desiredCount": "<integer>",
    "virtualPerPhysical": 128
  },
  "replicationConfig": {
    "factor": 1,
    "asyncEnabled": "<boolean>"
  },
  "invertedIndexConfig": {
    "cleanupIntervalSeconds": 60,
    "bm25": {
      "k1": 1.2,
      "b": 0.75
    },
    "stopwords": {
      "preset": "en"
    },
    "indexTimestamps": false,
    "indexNullState": false,
    "indexPropertyLength": false
  },
  "multiTenancyConfig": {
    "enabled": false,
    "autoTenantCreation": "<boolean>",
    "autoTenantActivation": "<boolean>"
  },
  "vectorizer": "<vectorizer_module_name>",
  "moduleConfig": {
    "<module_name>": {
      "vectorizeClassName": true
    }
  },
  "description": "<string>",
  "properties": [
    {
      "name": "<string>",
      "dataType": [
        "uuid",
        "string[]"
      ],
      "description": "<string>",
      "moduleConfig": {
        "<module_name>": {
          "skip": false,
          "vectorizePropertyName": true
        }
      },
      "indexInverted": true,
      "indexFilterable": true,
      "indexSearchable": true,
      "indexRangeFilters": "<boolean>",
      "tokenization": "word",
      "nestedProperties": [
        {
          "name": "<string>",
          "dataType": [
            "number",
            "blob"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        },
        {
          "name": "<string>",
          "dataType": [
            "date",
            "<cross_reference>"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        }
      ]
    },
    {
      "name": "<string>",
      "dataType": [
        "object",
        "number[]"
      ],
      "description": "<string>",
      "moduleConfig": {
        "<module_name>": {
          "skip": false,
          "vectorizePropertyName": true
        }
      },
      "indexInverted": true,
      "indexFilterable": true,
      "indexSearchable": true,
      "indexRangeFilters": "<boolean>",
      "tokenization": "word",
      "nestedProperties": [
        {
          "name": "<string>",
          "dataType": [
            "<cross_reference>",
            "blob"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        },
        {
          "name": "<string>",
          "dataType": [
            "<cross_reference>",
            "string[]"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        }
      ]
    }
  ]
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/schema/:className",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className"
],
variable: [
{
key: "className"
}
]
}
},
status: "Unauthorized",
code: 401,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Forbidden",
originalRequest: {
method: "PUT",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<string>",
  "vectorConfig": {
    "<vector_name>": {
      "vectorizer": "none",
      "vectorIndexType": "hnsw",
      "vectorIndexConfig": {}
    }
  },
  "vectorIndexType": "hnsw",
  "vectorIndexConfig": {},
  "shardingConfig": {
    "desiredCount": "<integer>",
    "virtualPerPhysical": 128
  },
  "replicationConfig": {
    "factor": 1,
    "asyncEnabled": "<boolean>"
  },
  "invertedIndexConfig": {
    "cleanupIntervalSeconds": 60,
    "bm25": {
      "k1": 1.2,
      "b": 0.75
    },
    "stopwords": {
      "preset": "en"
    },
    "indexTimestamps": false,
    "indexNullState": false,
    "indexPropertyLength": false
  },
  "multiTenancyConfig": {
    "enabled": false,
    "autoTenantCreation": "<boolean>",
    "autoTenantActivation": "<boolean>"
  },
  "vectorizer": "<vectorizer_module_name>",
  "moduleConfig": {
    "<module_name>": {
      "vectorizeClassName": true
    }
  },
  "description": "<string>",
  "properties": [
    {
      "name": "<string>",
      "dataType": [
        "uuid",
        "string[]"
      ],
      "description": "<string>",
      "moduleConfig": {
        "<module_name>": {
          "skip": false,
          "vectorizePropertyName": true
        }
      },
      "indexInverted": true,
      "indexFilterable": true,
      "indexSearchable": true,
      "indexRangeFilters": "<boolean>",
      "tokenization": "word",
      "nestedProperties": [
        {
          "name": "<string>",
          "dataType": [
            "number",
            "blob"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        },
        {
          "name": "<string>",
          "dataType": [
            "date",
            "<cross_reference>"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        }
      ]
    },
    {
      "name": "<string>",
      "dataType": [
        "object",
        "number[]"
      ],
      "description": "<string>",
      "moduleConfig": {
        "<module_name>": {
          "skip": false,
          "vectorizePropertyName": true
        }
      },
      "indexInverted": true,
      "indexFilterable": true,
      "indexSearchable": true,
      "indexRangeFilters": "<boolean>",
      "tokenization": "word",
      "nestedProperties": [
        {
          "name": "<string>",
          "dataType": [
            "<cross_reference>",
            "blob"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        },
        {
          "name": "<string>",
          "dataType": [
            "<cross_reference>",
            "string[]"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        }
      ]
    }
  ]
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/schema/:className",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className"
],
variable: [
{
key: "className"
}
]
}
},
status: "Forbidden",
code: 403,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Class to be updated does not exist",
originalRequest: {
method: "PUT",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<string>",
  "vectorConfig": {
    "<vector_name>": {
      "vectorizer": "none",
      "vectorIndexType": "hnsw",
      "vectorIndexConfig": {}
    }
  },
  "vectorIndexType": "hnsw",
  "vectorIndexConfig": {},
  "shardingConfig": {
    "desiredCount": "<integer>",
    "virtualPerPhysical": 128
  },
  "replicationConfig": {
    "factor": 1,
    "asyncEnabled": "<boolean>"
  },
  "invertedIndexConfig": {
    "cleanupIntervalSeconds": 60,
    "bm25": {
      "k1": 1.2,
      "b": 0.75
    },
    "stopwords": {
      "preset": "en"
    },
    "indexTimestamps": false,
    "indexNullState": false,
    "indexPropertyLength": false
  },
  "multiTenancyConfig": {
    "enabled": false,
    "autoTenantCreation": "<boolean>",
    "autoTenantActivation": "<boolean>"
  },
  "vectorizer": "<vectorizer_module_name>",
  "moduleConfig": {
    "<module_name>": {
      "vectorizeClassName": true
    }
  },
  "description": "<string>",
  "properties": [
    {
      "name": "<string>",
      "dataType": [
        "uuid",
        "string[]"
      ],
      "description": "<string>",
      "moduleConfig": {
        "<module_name>": {
          "skip": false,
          "vectorizePropertyName": true
        }
      },
      "indexInverted": true,
      "indexFilterable": true,
      "indexSearchable": true,
      "indexRangeFilters": "<boolean>",
      "tokenization": "word",
      "nestedProperties": [
        {
          "name": "<string>",
          "dataType": [
            "number",
            "blob"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        },
        {
          "name": "<string>",
          "dataType": [
            "date",
            "<cross_reference>"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        }
      ]
    },
    {
      "name": "<string>",
      "dataType": [
        "object",
        "number[]"
      ],
      "description": "<string>",
      "moduleConfig": {
        "<module_name>": {
          "skip": false,
          "vectorizePropertyName": true
        }
      },
      "indexInverted": true,
      "indexFilterable": true,
      "indexSearchable": true,
      "indexRangeFilters": "<boolean>",
      "tokenization": "word",
      "nestedProperties": [
        {
          "name": "<string>",
          "dataType": [
            "<cross_reference>",
            "blob"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        },
        {
          "name": "<string>",
          "dataType": [
            "<cross_reference>",
            "string[]"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        }
      ]
    }
  ]
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/schema/:className",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className"
],
variable: [
{
key: "className"
}
]
}
},
status: "Not Found",
code: 404,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Invalid update attempt",
originalRequest: {
method: "PUT",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<string>",
  "vectorConfig": {
    "<vector_name>": {
      "vectorizer": "none",
      "vectorIndexType": "hnsw",
      "vectorIndexConfig": {}
    }
  },
  "vectorIndexType": "hnsw",
  "vectorIndexConfig": {},
  "shardingConfig": {
    "desiredCount": "<integer>",
    "virtualPerPhysical": 128
  },
  "replicationConfig": {
    "factor": 1,
    "asyncEnabled": "<boolean>"
  },
  "invertedIndexConfig": {
    "cleanupIntervalSeconds": 60,
    "bm25": {
      "k1": 1.2,
      "b": 0.75
    },
    "stopwords": {
      "preset": "en"
    },
    "indexTimestamps": false,
    "indexNullState": false,
    "indexPropertyLength": false
  },
  "multiTenancyConfig": {
    "enabled": false,
    "autoTenantCreation": "<boolean>",
    "autoTenantActivation": "<boolean>"
  },
  "vectorizer": "<vectorizer_module_name>",
  "moduleConfig": {
    "<module_name>": {
      "vectorizeClassName": true
    }
  },
  "description": "<string>",
  "properties": [
    {
      "name": "<string>",
      "dataType": [
        "uuid",
        "string[]"
      ],
      "description": "<string>",
      "moduleConfig": {
        "<module_name>": {
          "skip": false,
          "vectorizePropertyName": true
        }
      },
      "indexInverted": true,
      "indexFilterable": true,
      "indexSearchable": true,
      "indexRangeFilters": "<boolean>",
      "tokenization": "word",
      "nestedProperties": [
        {
          "name": "<string>",
          "dataType": [
            "number",
            "blob"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        },
        {
          "name": "<string>",
          "dataType": [
            "date",
            "<cross_reference>"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        }
      ]
    },
    {
      "name": "<string>",
      "dataType": [
        "object",
        "number[]"
      ],
      "description": "<string>",
      "moduleConfig": {
        "<module_name>": {
          "skip": false,
          "vectorizePropertyName": true
        }
      },
      "indexInverted": true,
      "indexFilterable": true,
      "indexSearchable": true,
      "indexRangeFilters": "<boolean>",
      "tokenization": "word",
      "nestedProperties": [
        {
          "name": "<string>",
          "dataType": [
            "<cross_reference>",
            "blob"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        },
        {
          "name": "<string>",
          "dataType": [
            "<cross_reference>",
            "string[]"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        }
      ]
    }
  ]
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/schema/:className",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className"
],
variable: [
{
key: "className"
}
]
}
},
status: "Unprocessable Entity (WebDAV) (RFC 4918)",
code: 422,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error.",
originalRequest: {
method: "PUT",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<string>",
  "vectorConfig": {
    "<vector_name>": {
      "vectorizer": "none",
      "vectorIndexType": "hnsw",
      "vectorIndexConfig": {}
    }
  },
  "vectorIndexType": "hnsw",
  "vectorIndexConfig": {},
  "shardingConfig": {
    "desiredCount": "<integer>",
    "virtualPerPhysical": 128
  },
  "replicationConfig": {
    "factor": 1,
    "asyncEnabled": "<boolean>"
  },
  "invertedIndexConfig": {
    "cleanupIntervalSeconds": 60,
    "bm25": {
      "k1": 1.2,
      "b": 0.75
    },
    "stopwords": {
      "preset": "en"
    },
    "indexTimestamps": false,
    "indexNullState": false,
    "indexPropertyLength": false
  },
  "multiTenancyConfig": {
    "enabled": false,
    "autoTenantCreation": "<boolean>",
    "autoTenantActivation": "<boolean>"
  },
  "vectorizer": "<vectorizer_module_name>",
  "moduleConfig": {
    "<module_name>": {
      "vectorizeClassName": true
    }
  },
  "description": "<string>",
  "properties": [
    {
      "name": "<string>",
      "dataType": [
        "uuid",
        "string[]"
      ],
      "description": "<string>",
      "moduleConfig": {
        "<module_name>": {
          "skip": false,
          "vectorizePropertyName": true
        }
      },
      "indexInverted": true,
      "indexFilterable": true,
      "indexSearchable": true,
      "indexRangeFilters": "<boolean>",
      "tokenization": "word",
      "nestedProperties": [
        {
          "name": "<string>",
          "dataType": [
            "number",
            "blob"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        },
        {
          "name": "<string>",
          "dataType": [
            "date",
            "<cross_reference>"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        }
      ]
    },
    {
      "name": "<string>",
      "dataType": [
        "object",
        "number[]"
      ],
      "description": "<string>",
      "moduleConfig": {
        "<module_name>": {
          "skip": false,
          "vectorizePropertyName": true
        }
      },
      "indexInverted": true,
      "indexFilterable": true,
      "indexSearchable": true,
      "indexRangeFilters": "<boolean>",
      "tokenization": "word",
      "nestedProperties": [
        {
          "name": "<string>",
          "dataType": [
            "<cross_reference>",
            "blob"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        },
        {
          "name": "<string>",
          "dataType": [
            "<cross_reference>",
            "string[]"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        }
      ]
    }
  ]
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/schema/:className",
host: [
"{{baseUrl}}"
],
path: [
"schema",
":className"
],
variable: [
{
key: "className"
}
]
}
},
status: "Internal Server Error",
code: 500,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
}
]
}
]
},
{
name: "Get the entire schema.",
request: {
method: "GET",
header: [
{
key: "consistency",
value: "true",
description: "If consistency is true, the request will be proxied to the leader to ensure strong schema consistency"
},
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/schema",
host: [
"{{baseUrl}}"
],
path: [
"schema"
]
},
description: "Fetch an array of all collection definitions from the schema."
},
response: [
{
name: "Successfully dumped the database schema.",
originalRequest: {
method: "GET",
header: [
{
key: "consistency",
value: "true",
description: "If consistency is true, the request will be proxied to the leader to ensure strong schema consistency"
},
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/schema",
host: [
"{{baseUrl}}"
],
path: [
"schema"
]
}
},
status: "OK",
code: 200,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "classes": [
    {
      "class": "<string>",
      "vectorConfig": {
        "<vector_name>": {
          "vectorizer": "<vectorizer_module_name>",
          "vectorIndexType": "hnsw",
          "vectorIndexConfig": {}
        }
      },
      "vectorIndexType": "hnsw",
      "vectorIndexConfig": {},
      "shardingConfig": {
        "desiredCount": "<integer>",
        "virtualPerPhysical": 128
      },
      "replicationConfig": {
        "factor": 1,
        "asyncEnabled": "<boolean>"
      },
      "invertedIndexConfig": {
        "cleanupIntervalSeconds": 60,
        "bm25": {
          "k1": 1.2,
          "b": 0.75
        },
        "stopwords": {
          "preset": "en"
        },
        "indexTimestamps": false,
        "indexNullState": false,
        "indexPropertyLength": false
      },
      "multiTenancyConfig": {
        "enabled": false,
        "autoTenantCreation": "<boolean>",
        "autoTenantActivation": "<boolean>"
      },
      "vectorizer": "<vectorizer_module_name>",
      "moduleConfig": {
        "<module_name>": {
          "vectorizeClassName": true
        }
      },
      "description": "<string>",
      "properties": [
        {
          "name": "<string>",
          "dataType": [
            "object[]",
            "blob"
          ],
          "description": "<string>",
          "moduleConfig": {
            "<module_name>": {
              "skip": false,
              "vectorizePropertyName": true
            }
          },
          "indexInverted": true,
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "name": "<string>",
              "dataType": [
                "uuid",
                "string"
              ],
              "description": "<string>",
              "indexFilterable": true,
              "indexSearchable": true,
              "indexRangeFilters": "<boolean>",
              "tokenization": "word",
              "nestedProperties": [
                {
                  "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
                },
                {
                  "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
                }
              ]
            },
            {
              "name": "<string>",
              "dataType": [
                "geoCoordinates",
                "uuid[]"
              ],
              "description": "<string>",
              "indexFilterable": true,
              "indexSearchable": true,
              "indexRangeFilters": "<boolean>",
              "tokenization": "word",
              "nestedProperties": [
                {
                  "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
                },
                {
                  "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
                }
              ]
            }
          ]
        },
        {
          "name": "<string>",
          "dataType": [
            "int[]",
            "string[]"
          ],
          "description": "<string>",
          "moduleConfig": {
            "<module_name>": {
              "skip": false,
              "vectorizePropertyName": true
            }
          },
          "indexInverted": true,
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "name": "<string>",
              "dataType": [
                "object",
                "object"
              ],
              "description": "<string>",
              "indexFilterable": true,
              "indexSearchable": true,
              "indexRangeFilters": "<boolean>",
              "tokenization": "word",
              "nestedProperties": [
                {
                  "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
                },
                {
                  "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
                }
              ]
            },
            {
              "name": "<string>",
              "dataType": [
                "number",
                "date"
              ],
              "description": "<string>",
              "indexFilterable": true,
              "indexSearchable": true,
              "indexRangeFilters": "<boolean>",
              "tokenization": "word",
              "nestedProperties": [
                {
                  "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
                },
                {
                  "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "class": "<string>",
      "vectorConfig": {
        "<vector_name>": {
          "vectorizer": "none",
          "vectorIndexType": "hnsw",
          "vectorIndexConfig": {}
        }
      },
      "vectorIndexType": "hnsw",
      "vectorIndexConfig": {},
      "shardingConfig": {
        "desiredCount": "<integer>",
        "virtualPerPhysical": 128
      },
      "replicationConfig": {
        "factor": 1,
        "asyncEnabled": "<boolean>"
      },
      "invertedIndexConfig": {
        "cleanupIntervalSeconds": 60,
        "bm25": {
          "k1": 1.2,
          "b": 0.75
        },
        "stopwords": {
          "preset": "en"
        },
        "indexTimestamps": false,
        "indexNullState": false,
        "indexPropertyLength": false
      },
      "multiTenancyConfig": {
        "enabled": false,
        "autoTenantCreation": "<boolean>",
        "autoTenantActivation": "<boolean>"
      },
      "vectorizer": "none",
      "moduleConfig": {
        "<module_name>": {
          "vectorizeClassName": true
        }
      },
      "description": "<string>",
      "properties": [
        {
          "name": "<string>",
          "dataType": [
            "object",
            "object"
          ],
          "description": "<string>",
          "moduleConfig": {
            "<module_name>": {
              "skip": false,
              "vectorizePropertyName": true
            }
          },
          "indexInverted": true,
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "name": "<string>",
              "dataType": [
                "phoneNumber",
                "geoCoordinates"
              ],
              "description": "<string>",
              "indexFilterable": true,
              "indexSearchable": true,
              "indexRangeFilters": "<boolean>",
              "tokenization": "word",
              "nestedProperties": [
                {
                  "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
                },
                {
                  "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
                }
              ]
            },
            {
              "name": "<string>",
              "dataType": [
                "number",
                "object"
              ],
              "description": "<string>",
              "indexFilterable": true,
              "indexSearchable": true,
              "indexRangeFilters": "<boolean>",
              "tokenization": "word",
              "nestedProperties": [
                {
                  "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
                },
                {
                  "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
                }
              ]
            }
          ]
        },
        {
          "name": "<string>",
          "dataType": [
            "uuid[]",
            "uuid[]"
          ],
          "description": "<string>",
          "moduleConfig": {
            "<module_name>": {
              "skip": false,
              "vectorizePropertyName": true
            }
          },
          "indexInverted": true,
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "name": "<string>",
              "dataType": [
                "number",
                "phoneNumber"
              ],
              "description": "<string>",
              "indexFilterable": true,
              "indexSearchable": true,
              "indexRangeFilters": "<boolean>",
              "tokenization": "word",
              "nestedProperties": [
                {
                  "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
                },
                {
                  "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
                }
              ]
            },
            {
              "name": "<string>",
              "dataType": [
                "phoneNumber",
                "object[]"
              ],
              "description": "<string>",
              "indexFilterable": true,
              "indexSearchable": true,
              "indexRangeFilters": "<boolean>",
              "tokenization": "word",
              "nestedProperties": [
                {
                  "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
                },
                {
                  "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
                }
              ]
            }
          ]
        }
      ]
    }
  ],
  "maintainer": "<email>",
  "name": "<string>"
}"
},
{
name: "Unauthorized or invalid credentials.",
originalRequest: {
method: "GET",
header: [
{
key: "consistency",
value: "true",
description: "If consistency is true, the request will be proxied to the leader to ensure strong schema consistency"
}
],
url: {
raw: "{{baseUrl}}/schema",
host: [
"{{baseUrl}}"
],
path: [
"schema"
]
}
},
status: "Unauthorized",
code: 401,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Forbidden",
originalRequest: {
method: "GET",
header: [
{
key: "consistency",
value: "true",
description: "If consistency is true, the request will be proxied to the leader to ensure strong schema consistency"
},
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/schema",
host: [
"{{baseUrl}}"
],
path: [
"schema"
]
}
},
status: "Forbidden",
code: 403,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error.",
originalRequest: {
method: "GET",
header: [
{
key: "consistency",
value: "true",
description: "If consistency is true, the request will be proxied to the leader to ensure strong schema consistency"
},
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/schema",
host: [
"{{baseUrl}}"
],
path: [
"schema"
]
}
},
status: "Internal Server Error",
code: 500,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
}
]
},
{
name: "Create a collection.",
request: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<string>",
  "vectorConfig": {
    "<vector_name>": {
      "vectorizer": "none",
      "vectorIndexType": "hnsw",
      "vectorIndexConfig": {}
    }
  },
  "vectorIndexType": "hnsw",
  "vectorIndexConfig": {},
  "shardingConfig": {
    "desiredCount": "<integer>",
    "virtualPerPhysical": 128
  },
  "replicationConfig": {
    "factor": 1,
    "asyncEnabled": "<boolean>"
  },
  "invertedIndexConfig": {
    "cleanupIntervalSeconds": 60,
    "bm25": {
      "k1": 1.2,
      "b": 0.75
    },
    "stopwords": {
      "preset": "en"
    },
    "indexTimestamps": false,
    "indexNullState": false,
    "indexPropertyLength": false
  },
  "multiTenancyConfig": {
    "enabled": false,
    "autoTenantCreation": "<boolean>",
    "autoTenantActivation": "<boolean>"
  },
  "vectorizer": "<vectorizer_module_name>",
  "moduleConfig": {
    "<module_name>": {
      "vectorizeClassName": true
    }
  },
  "description": "<string>",
  "properties": [
    {
      "name": "<string>",
      "dataType": [
        "uuid",
        "string[]"
      ],
      "description": "<string>",
      "moduleConfig": {
        "<module_name>": {
          "skip": false,
          "vectorizePropertyName": true
        }
      },
      "indexInverted": true,
      "indexFilterable": true,
      "indexSearchable": true,
      "indexRangeFilters": "<boolean>",
      "tokenization": "word",
      "nestedProperties": [
        {
          "name": "<string>",
          "dataType": [
            "number",
            "blob"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        },
        {
          "name": "<string>",
          "dataType": [
            "date",
            "<cross_reference>"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        }
      ]
    },
    {
      "name": "<string>",
      "dataType": [
        "object",
        "number[]"
      ],
      "description": "<string>",
      "moduleConfig": {
        "<module_name>": {
          "skip": false,
          "vectorizePropertyName": true
        }
      },
      "indexInverted": true,
      "indexFilterable": true,
      "indexSearchable": true,
      "indexRangeFilters": "<boolean>",
      "tokenization": "word",
      "nestedProperties": [
        {
          "name": "<string>",
          "dataType": [
            "<cross_reference>",
            "blob"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        },
        {
          "name": "<string>",
          "dataType": [
            "<cross_reference>",
            "string[]"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        }
      ]
    }
  ]
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/schema",
host: [
"{{baseUrl}}"
],
path: [
"schema"
]
},
description: "Create a new data object collection. <br/><br/>If [AutoSchema](https://weaviate.io/developers/weaviate/config-refs/schema#auto-schema) is enabled, Weaviate will attempt to infer the schema from the data at import time. However, manual schema definition is recommended for production environments. <br/><br/>For further discussions of parameters, please see the [schema reference page](https://weaviate.io/developers/weaviate/config-refs/schema)."
},
response: [
{
name: "Added the new Object class to the schema.",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<string>",
  "vectorConfig": {
    "<vector_name>": {
      "vectorizer": "none",
      "vectorIndexType": "hnsw",
      "vectorIndexConfig": {}
    }
  },
  "vectorIndexType": "hnsw",
  "vectorIndexConfig": {},
  "shardingConfig": {
    "desiredCount": "<integer>",
    "virtualPerPhysical": 128
  },
  "replicationConfig": {
    "factor": 1,
    "asyncEnabled": "<boolean>"
  },
  "invertedIndexConfig": {
    "cleanupIntervalSeconds": 60,
    "bm25": {
      "k1": 1.2,
      "b": 0.75
    },
    "stopwords": {
      "preset": "en"
    },
    "indexTimestamps": false,
    "indexNullState": false,
    "indexPropertyLength": false
  },
  "multiTenancyConfig": {
    "enabled": false,
    "autoTenantCreation": "<boolean>",
    "autoTenantActivation": "<boolean>"
  },
  "vectorizer": "<vectorizer_module_name>",
  "moduleConfig": {
    "<module_name>": {
      "vectorizeClassName": true
    }
  },
  "description": "<string>",
  "properties": [
    {
      "name": "<string>",
      "dataType": [
        "uuid",
        "string[]"
      ],
      "description": "<string>",
      "moduleConfig": {
        "<module_name>": {
          "skip": false,
          "vectorizePropertyName": true
        }
      },
      "indexInverted": true,
      "indexFilterable": true,
      "indexSearchable": true,
      "indexRangeFilters": "<boolean>",
      "tokenization": "word",
      "nestedProperties": [
        {
          "name": "<string>",
          "dataType": [
            "number",
            "blob"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        },
        {
          "name": "<string>",
          "dataType": [
            "date",
            "<cross_reference>"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        }
      ]
    },
    {
      "name": "<string>",
      "dataType": [
        "object",
        "number[]"
      ],
      "description": "<string>",
      "moduleConfig": {
        "<module_name>": {
          "skip": false,
          "vectorizePropertyName": true
        }
      },
      "indexInverted": true,
      "indexFilterable": true,
      "indexSearchable": true,
      "indexRangeFilters": "<boolean>",
      "tokenization": "word",
      "nestedProperties": [
        {
          "name": "<string>",
          "dataType": [
            "<cross_reference>",
            "blob"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        },
        {
          "name": "<string>",
          "dataType": [
            "<cross_reference>",
            "string[]"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        }
      ]
    }
  ]
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/schema",
host: [
"{{baseUrl}}"
],
path: [
"schema"
]
}
},
status: "OK",
code: 200,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "class": "<string>",
  "vectorConfig": {
    "<vector_name>": {
      "vectorizer": "none",
      "vectorIndexType": "hnsw",
      "vectorIndexConfig": {}
    }
  },
  "vectorIndexType": "hnsw",
  "vectorIndexConfig": {},
  "shardingConfig": {
    "desiredCount": "<integer>",
    "virtualPerPhysical": 128
  },
  "replicationConfig": {
    "factor": 1,
    "asyncEnabled": "<boolean>"
  },
  "invertedIndexConfig": {
    "cleanupIntervalSeconds": 60,
    "bm25": {
      "k1": 1.2,
      "b": 0.75
    },
    "stopwords": {
      "preset": "en"
    },
    "indexTimestamps": false,
    "indexNullState": false,
    "indexPropertyLength": false
  },
  "multiTenancyConfig": {
    "enabled": false,
    "autoTenantCreation": "<boolean>",
    "autoTenantActivation": "<boolean>"
  },
  "vectorizer": "<vectorizer_module_name>",
  "moduleConfig": {
    "<module_name>": {
      "vectorizeClassName": true
    }
  },
  "description": "<string>",
  "properties": [
    {
      "name": "<string>",
      "dataType": [
        "uuid",
        "string[]"
      ],
      "description": "<string>",
      "moduleConfig": {
        "<module_name>": {
          "skip": false,
          "vectorizePropertyName": true
        }
      },
      "indexInverted": true,
      "indexFilterable": true,
      "indexSearchable": true,
      "indexRangeFilters": "<boolean>",
      "tokenization": "word",
      "nestedProperties": [
        {
          "name": "<string>",
          "dataType": [
            "number",
            "blob"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        },
        {
          "name": "<string>",
          "dataType": [
            "date",
            "<cross_reference>"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        }
      ]
    },
    {
      "name": "<string>",
      "dataType": [
        "object",
        "number[]"
      ],
      "description": "<string>",
      "moduleConfig": {
        "<module_name>": {
          "skip": false,
          "vectorizePropertyName": true
        }
      },
      "indexInverted": true,
      "indexFilterable": true,
      "indexSearchable": true,
      "indexRangeFilters": "<boolean>",
      "tokenization": "word",
      "nestedProperties": [
        {
          "name": "<string>",
          "dataType": [
            "<cross_reference>",
            "blob"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        },
        {
          "name": "<string>",
          "dataType": [
            "<cross_reference>",
            "string[]"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        }
      ]
    }
  ]
}"
},
{
name: "Unauthorized or invalid credentials.",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<string>",
  "vectorConfig": {
    "<vector_name>": {
      "vectorizer": "none",
      "vectorIndexType": "hnsw",
      "vectorIndexConfig": {}
    }
  },
  "vectorIndexType": "hnsw",
  "vectorIndexConfig": {},
  "shardingConfig": {
    "desiredCount": "<integer>",
    "virtualPerPhysical": 128
  },
  "replicationConfig": {
    "factor": 1,
    "asyncEnabled": "<boolean>"
  },
  "invertedIndexConfig": {
    "cleanupIntervalSeconds": 60,
    "bm25": {
      "k1": 1.2,
      "b": 0.75
    },
    "stopwords": {
      "preset": "en"
    },
    "indexTimestamps": false,
    "indexNullState": false,
    "indexPropertyLength": false
  },
  "multiTenancyConfig": {
    "enabled": false,
    "autoTenantCreation": "<boolean>",
    "autoTenantActivation": "<boolean>"
  },
  "vectorizer": "<vectorizer_module_name>",
  "moduleConfig": {
    "<module_name>": {
      "vectorizeClassName": true
    }
  },
  "description": "<string>",
  "properties": [
    {
      "name": "<string>",
      "dataType": [
        "uuid",
        "string[]"
      ],
      "description": "<string>",
      "moduleConfig": {
        "<module_name>": {
          "skip": false,
          "vectorizePropertyName": true
        }
      },
      "indexInverted": true,
      "indexFilterable": true,
      "indexSearchable": true,
      "indexRangeFilters": "<boolean>",
      "tokenization": "word",
      "nestedProperties": [
        {
          "name": "<string>",
          "dataType": [
            "number",
            "blob"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        },
        {
          "name": "<string>",
          "dataType": [
            "date",
            "<cross_reference>"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        }
      ]
    },
    {
      "name": "<string>",
      "dataType": [
        "object",
        "number[]"
      ],
      "description": "<string>",
      "moduleConfig": {
        "<module_name>": {
          "skip": false,
          "vectorizePropertyName": true
        }
      },
      "indexInverted": true,
      "indexFilterable": true,
      "indexSearchable": true,
      "indexRangeFilters": "<boolean>",
      "tokenization": "word",
      "nestedProperties": [
        {
          "name": "<string>",
          "dataType": [
            "<cross_reference>",
            "blob"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        },
        {
          "name": "<string>",
          "dataType": [
            "<cross_reference>",
            "string[]"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        }
      ]
    }
  ]
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/schema",
host: [
"{{baseUrl}}"
],
path: [
"schema"
]
}
},
status: "Unauthorized",
code: 401,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Forbidden",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<string>",
  "vectorConfig": {
    "<vector_name>": {
      "vectorizer": "none",
      "vectorIndexType": "hnsw",
      "vectorIndexConfig": {}
    }
  },
  "vectorIndexType": "hnsw",
  "vectorIndexConfig": {},
  "shardingConfig": {
    "desiredCount": "<integer>",
    "virtualPerPhysical": 128
  },
  "replicationConfig": {
    "factor": 1,
    "asyncEnabled": "<boolean>"
  },
  "invertedIndexConfig": {
    "cleanupIntervalSeconds": 60,
    "bm25": {
      "k1": 1.2,
      "b": 0.75
    },
    "stopwords": {
      "preset": "en"
    },
    "indexTimestamps": false,
    "indexNullState": false,
    "indexPropertyLength": false
  },
  "multiTenancyConfig": {
    "enabled": false,
    "autoTenantCreation": "<boolean>",
    "autoTenantActivation": "<boolean>"
  },
  "vectorizer": "<vectorizer_module_name>",
  "moduleConfig": {
    "<module_name>": {
      "vectorizeClassName": true
    }
  },
  "description": "<string>",
  "properties": [
    {
      "name": "<string>",
      "dataType": [
        "uuid",
        "string[]"
      ],
      "description": "<string>",
      "moduleConfig": {
        "<module_name>": {
          "skip": false,
          "vectorizePropertyName": true
        }
      },
      "indexInverted": true,
      "indexFilterable": true,
      "indexSearchable": true,
      "indexRangeFilters": "<boolean>",
      "tokenization": "word",
      "nestedProperties": [
        {
          "name": "<string>",
          "dataType": [
            "number",
            "blob"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        },
        {
          "name": "<string>",
          "dataType": [
            "date",
            "<cross_reference>"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        }
      ]
    },
    {
      "name": "<string>",
      "dataType": [
        "object",
        "number[]"
      ],
      "description": "<string>",
      "moduleConfig": {
        "<module_name>": {
          "skip": false,
          "vectorizePropertyName": true
        }
      },
      "indexInverted": true,
      "indexFilterable": true,
      "indexSearchable": true,
      "indexRangeFilters": "<boolean>",
      "tokenization": "word",
      "nestedProperties": [
        {
          "name": "<string>",
          "dataType": [
            "<cross_reference>",
            "blob"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        },
        {
          "name": "<string>",
          "dataType": [
            "<cross_reference>",
            "string[]"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        }
      ]
    }
  ]
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/schema",
host: [
"{{baseUrl}}"
],
path: [
"schema"
]
}
},
status: "Forbidden",
code: 403,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Invalid Object class",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<string>",
  "vectorConfig": {
    "<vector_name>": {
      "vectorizer": "none",
      "vectorIndexType": "hnsw",
      "vectorIndexConfig": {}
    }
  },
  "vectorIndexType": "hnsw",
  "vectorIndexConfig": {},
  "shardingConfig": {
    "desiredCount": "<integer>",
    "virtualPerPhysical": 128
  },
  "replicationConfig": {
    "factor": 1,
    "asyncEnabled": "<boolean>"
  },
  "invertedIndexConfig": {
    "cleanupIntervalSeconds": 60,
    "bm25": {
      "k1": 1.2,
      "b": 0.75
    },
    "stopwords": {
      "preset": "en"
    },
    "indexTimestamps": false,
    "indexNullState": false,
    "indexPropertyLength": false
  },
  "multiTenancyConfig": {
    "enabled": false,
    "autoTenantCreation": "<boolean>",
    "autoTenantActivation": "<boolean>"
  },
  "vectorizer": "<vectorizer_module_name>",
  "moduleConfig": {
    "<module_name>": {
      "vectorizeClassName": true
    }
  },
  "description": "<string>",
  "properties": [
    {
      "name": "<string>",
      "dataType": [
        "uuid",
        "string[]"
      ],
      "description": "<string>",
      "moduleConfig": {
        "<module_name>": {
          "skip": false,
          "vectorizePropertyName": true
        }
      },
      "indexInverted": true,
      "indexFilterable": true,
      "indexSearchable": true,
      "indexRangeFilters": "<boolean>",
      "tokenization": "word",
      "nestedProperties": [
        {
          "name": "<string>",
          "dataType": [
            "number",
            "blob"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        },
        {
          "name": "<string>",
          "dataType": [
            "date",
            "<cross_reference>"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        }
      ]
    },
    {
      "name": "<string>",
      "dataType": [
        "object",
        "number[]"
      ],
      "description": "<string>",
      "moduleConfig": {
        "<module_name>": {
          "skip": false,
          "vectorizePropertyName": true
        }
      },
      "indexInverted": true,
      "indexFilterable": true,
      "indexSearchable": true,
      "indexRangeFilters": "<boolean>",
      "tokenization": "word",
      "nestedProperties": [
        {
          "name": "<string>",
          "dataType": [
            "<cross_reference>",
            "blob"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        },
        {
          "name": "<string>",
          "dataType": [
            "<cross_reference>",
            "string[]"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        }
      ]
    }
  ]
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/schema",
host: [
"{{baseUrl}}"
],
path: [
"schema"
]
}
},
status: "Unprocessable Entity (WebDAV) (RFC 4918)",
code: 422,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error.",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "class": "<string>",
  "vectorConfig": {
    "<vector_name>": {
      "vectorizer": "none",
      "vectorIndexType": "hnsw",
      "vectorIndexConfig": {}
    }
  },
  "vectorIndexType": "hnsw",
  "vectorIndexConfig": {},
  "shardingConfig": {
    "desiredCount": "<integer>",
    "virtualPerPhysical": 128
  },
  "replicationConfig": {
    "factor": 1,
    "asyncEnabled": "<boolean>"
  },
  "invertedIndexConfig": {
    "cleanupIntervalSeconds": 60,
    "bm25": {
      "k1": 1.2,
      "b": 0.75
    },
    "stopwords": {
      "preset": "en"
    },
    "indexTimestamps": false,
    "indexNullState": false,
    "indexPropertyLength": false
  },
  "multiTenancyConfig": {
    "enabled": false,
    "autoTenantCreation": "<boolean>",
    "autoTenantActivation": "<boolean>"
  },
  "vectorizer": "<vectorizer_module_name>",
  "moduleConfig": {
    "<module_name>": {
      "vectorizeClassName": true
    }
  },
  "description": "<string>",
  "properties": [
    {
      "name": "<string>",
      "dataType": [
        "uuid",
        "string[]"
      ],
      "description": "<string>",
      "moduleConfig": {
        "<module_name>": {
          "skip": false,
          "vectorizePropertyName": true
        }
      },
      "indexInverted": true,
      "indexFilterable": true,
      "indexSearchable": true,
      "indexRangeFilters": "<boolean>",
      "tokenization": "word",
      "nestedProperties": [
        {
          "name": "<string>",
          "dataType": [
            "number",
            "blob"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        },
        {
          "name": "<string>",
          "dataType": [
            "date",
            "<cross_reference>"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        }
      ]
    },
    {
      "name": "<string>",
      "dataType": [
        "object",
        "number[]"
      ],
      "description": "<string>",
      "moduleConfig": {
        "<module_name>": {
          "skip": false,
          "vectorizePropertyName": true
        }
      },
      "indexInverted": true,
      "indexFilterable": true,
      "indexSearchable": true,
      "indexRangeFilters": "<boolean>",
      "tokenization": "word",
      "nestedProperties": [
        {
          "name": "<string>",
          "dataType": [
            "<cross_reference>",
            "blob"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        },
        {
          "name": "<string>",
          "dataType": [
            "<cross_reference>",
            "string[]"
          ],
          "description": "<string>",
          "indexFilterable": true,
          "indexSearchable": true,
          "indexRangeFilters": "<boolean>",
          "tokenization": "word",
          "nestedProperties": [
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            },
            {
              "value": "<Circular reference to #/components/schemas/NestedProperty detected>"
            }
          ]
        }
      ]
    }
  ]
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/schema",
host: [
"{{baseUrl}}"
],
path: [
"schema"
]
}
},
status: "Internal Server Error",
code: 500,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
}
]
}
]
},
{
name: "backups",
item: [
{
name: "{backend}",
item: [
{
name: "{id}",
item: [
{
name: "restore",
item: [
{
name: "Start a restoration process",
request: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "config": {
    "CPUPercentage": 50
  },
  "include": [
    "<string>",
    "<string>"
  ],
  "exclude": [
    "<string>",
    "<string>"
  ],
  "node_mapping": {
    "cupidatat_65": "<string>",
    "eu_9": "<string>",
    "aliquip_5b_": "<string>"
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/backups/:backend/:id/restore",
host: [
"{{baseUrl}}"
],
path: [
"backups",
":backend",
":id",
"restore"
],
variable: [
{
key: "backend",
value: "<string>",
description: "(Required) Backup backend name e.g. `filesystem`, `gcs`, `s3`, `azure`."
},
{
key: "id",
value: "<string>",
description: "(Required) The ID of a backup. Must be URL-safe and work as a filesystem path, only lowercase, numbers, underscore, minus characters allowed."
}
]
},
description: "Starts a process of restoring a backup for a set of collections. <br/><br/>Any backup can be restored to any machine, as long as the number of nodes between source and target are identical.<br/><br/>Requrements:<br/><br/>- None of the collections to be restored already exist on the target restoration node(s).<br/>- The node names of the backed-up collections' must match those of the target restoration node(s)."
},
response: [
{
name: "Backup restoration process successfully started.",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "config": {
    "CPUPercentage": 50
  },
  "include": [
    "<string>",
    "<string>"
  ],
  "exclude": [
    "<string>",
    "<string>"
  ],
  "node_mapping": {
    "cupidatat_65": "<string>",
    "eu_9": "<string>",
    "aliquip_5b_": "<string>"
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/backups/:backend/:id/restore",
host: [
"{{baseUrl}}"
],
path: [
"backups",
":backend",
":id",
"restore"
],
variable: [
{
key: "backend"
},
{
key: "id"
}
]
}
},
status: "OK",
code: 200,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "id": "<string>",
  "classes": [
    "<string>",
    "<string>"
  ],
  "backend": "<string>",
  "path": "<string>",
  "error": "<string>",
  "status": "STARTED"
}"
},
{
name: "Unauthorized or invalid credentials.",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "config": {
    "CPUPercentage": 50
  },
  "include": [
    "<string>",
    "<string>"
  ],
  "exclude": [
    "<string>",
    "<string>"
  ],
  "node_mapping": {
    "cupidatat_65": "<string>",
    "eu_9": "<string>",
    "aliquip_5b_": "<string>"
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/backups/:backend/:id/restore",
host: [
"{{baseUrl}}"
],
path: [
"backups",
":backend",
":id",
"restore"
],
variable: [
{
key: "backend"
},
{
key: "id"
}
]
}
},
status: "Unauthorized",
code: 401,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Forbidden",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "config": {
    "CPUPercentage": 50
  },
  "include": [
    "<string>",
    "<string>"
  ],
  "exclude": [
    "<string>",
    "<string>"
  ],
  "node_mapping": {
    "cupidatat_65": "<string>",
    "eu_9": "<string>",
    "aliquip_5b_": "<string>"
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/backups/:backend/:id/restore",
host: [
"{{baseUrl}}"
],
path: [
"backups",
":backend",
":id",
"restore"
],
variable: [
{
key: "backend"
},
{
key: "id"
}
]
}
},
status: "Forbidden",
code: 403,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Not Found - Backup does not exist",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "config": {
    "CPUPercentage": 50
  },
  "include": [
    "<string>",
    "<string>"
  ],
  "exclude": [
    "<string>",
    "<string>"
  ],
  "node_mapping": {
    "cupidatat_65": "<string>",
    "eu_9": "<string>",
    "aliquip_5b_": "<string>"
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/backups/:backend/:id/restore",
host: [
"{{baseUrl}}"
],
path: [
"backups",
":backend",
":id",
"restore"
],
variable: [
{
key: "backend"
},
{
key: "id"
}
]
}
},
status: "Not Found",
code: 404,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Invalid backup restoration attempt.",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "config": {
    "CPUPercentage": 50
  },
  "include": [
    "<string>",
    "<string>"
  ],
  "exclude": [
    "<string>",
    "<string>"
  ],
  "node_mapping": {
    "cupidatat_65": "<string>",
    "eu_9": "<string>",
    "aliquip_5b_": "<string>"
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/backups/:backend/:id/restore",
host: [
"{{baseUrl}}"
],
path: [
"backups",
":backend",
":id",
"restore"
],
variable: [
{
key: "backend"
},
{
key: "id"
}
]
}
},
status: "Unprocessable Entity (WebDAV) (RFC 4918)",
code: 422,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error.",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "config": {
    "CPUPercentage": 50
  },
  "include": [
    "<string>",
    "<string>"
  ],
  "exclude": [
    "<string>",
    "<string>"
  ],
  "node_mapping": {
    "cupidatat_65": "<string>",
    "eu_9": "<string>",
    "aliquip_5b_": "<string>"
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/backups/:backend/:id/restore",
host: [
"{{baseUrl}}"
],
path: [
"backups",
":backend",
":id",
"restore"
],
variable: [
{
key: "backend"
},
{
key: "id"
}
]
}
},
status: "Internal Server Error",
code: 500,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
}
]
},
{
name: "Get restore process status",
request: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/backups/:backend/:id/restore",
host: [
"{{baseUrl}}"
],
path: [
"backups",
":backend",
":id",
"restore"
],
variable: [
{
key: "backend",
value: "<string>",
description: "(Required) Backup backend name e.g. `filesystem`, `gcs`, `s3`, `azure`."
},
{
key: "id",
value: "<string>",
description: "(Required) The ID of a backup. Must be URL-safe and work as a filesystem path, only lowercase, numbers, underscore, minus characters allowed."
}
]
},
description: "Returns status of a backup restoration attempt for a set of classes. <br/><br/>All client implementations have a `wait for completion` option which will poll the backup status in the background and only return once the backup has completed (successfully or unsuccessfully). If you set the `wait for completion` option to false, you can also check the status yourself using the this endpoint."
},
response: [
{
name: "Backup restoration status successfully returned",
originalRequest: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/backups/:backend/:id/restore",
host: [
"{{baseUrl}}"
],
path: [
"backups",
":backend",
":id",
"restore"
],
variable: [
{
key: "backend"
},
{
key: "id"
}
]
}
},
status: "OK",
code: 200,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "id": "<string>",
  "backend": "<string>",
  "path": "<string>",
  "error": "<string>",
  "status": "STARTED"
}"
},
{
name: "Unauthorized or invalid credentials.",
originalRequest: {
method: "GET",
header: [ ],
url: {
raw: "{{baseUrl}}/backups/:backend/:id/restore",
host: [
"{{baseUrl}}"
],
path: [
"backups",
":backend",
":id",
"restore"
],
variable: [
{
key: "backend"
},
{
key: "id"
}
]
}
},
status: "Unauthorized",
code: 401,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Forbidden",
originalRequest: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/backups/:backend/:id/restore",
host: [
"{{baseUrl}}"
],
path: [
"backups",
":backend",
":id",
"restore"
],
variable: [
{
key: "backend"
},
{
key: "id"
}
]
}
},
status: "Forbidden",
code: 403,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Not Found - Backup does not exist",
originalRequest: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/backups/:backend/:id/restore",
host: [
"{{baseUrl}}"
],
path: [
"backups",
":backend",
":id",
"restore"
],
variable: [
{
key: "backend"
},
{
key: "id"
}
]
}
},
status: "Not Found",
code: 404,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error.",
originalRequest: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/backups/:backend/:id/restore",
host: [
"{{baseUrl}}"
],
path: [
"backups",
":backend",
":id",
"restore"
],
variable: [
{
key: "backend"
},
{
key: "id"
}
]
}
},
status: "Internal Server Error",
code: 500,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
}
]
}
]
},
{
name: "Get backup process status",
request: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/backups/:backend/:id",
host: [
"{{baseUrl}}"
],
path: [
"backups",
":backend",
":id"
],
variable: [
{
key: "backend",
value: "<string>",
description: "(Required) Backup backend name e.g. filesystem, gcs, s3."
},
{
key: "id",
value: "<string>",
description: "(Required) The ID of a backup. Must be URL-safe and work as a filesystem path, only lowercase, numbers, underscore, minus characters allowed."
}
]
},
description: "Returns status of backup creation attempt for a set of collections. <br/><br/>All client implementations have a `wait for completion` option which will poll the backup status in the background and only return once the backup has completed (successfully or unsuccessfully). If you set the `wait for completion` option to false, you can also check the status yourself using this endpoint."
},
response: [
{
name: "Backup creation status successfully returned",
originalRequest: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/backups/:backend/:id",
host: [
"{{baseUrl}}"
],
path: [
"backups",
":backend",
":id"
],
variable: [
{
key: "backend"
},
{
key: "id"
}
]
}
},
status: "OK",
code: 200,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "id": "<string>",
  "backend": "<string>",
  "path": "<string>",
  "error": "<string>",
  "status": "STARTED"
}"
},
{
name: "Unauthorized or invalid credentials.",
originalRequest: {
method: "GET",
header: [ ],
url: {
raw: "{{baseUrl}}/backups/:backend/:id",
host: [
"{{baseUrl}}"
],
path: [
"backups",
":backend",
":id"
],
variable: [
{
key: "backend"
},
{
key: "id"
}
]
}
},
status: "Unauthorized",
code: 401,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Forbidden",
originalRequest: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/backups/:backend/:id",
host: [
"{{baseUrl}}"
],
path: [
"backups",
":backend",
":id"
],
variable: [
{
key: "backend"
},
{
key: "id"
}
]
}
},
status: "Forbidden",
code: 403,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Not Found - Backup does not exist",
originalRequest: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/backups/:backend/:id",
host: [
"{{baseUrl}}"
],
path: [
"backups",
":backend",
":id"
],
variable: [
{
key: "backend"
},
{
key: "id"
}
]
}
},
status: "Not Found",
code: 404,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Invalid backup restoration status attempt.",
originalRequest: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/backups/:backend/:id",
host: [
"{{baseUrl}}"
],
path: [
"backups",
":backend",
":id"
],
variable: [
{
key: "backend"
},
{
key: "id"
}
]
}
},
status: "Unprocessable Entity (WebDAV) (RFC 4918)",
code: 422,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error.",
originalRequest: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/backups/:backend/:id",
host: [
"{{baseUrl}}"
],
path: [
"backups",
":backend",
":id"
],
variable: [
{
key: "backend"
},
{
key: "id"
}
]
}
},
status: "Internal Server Error",
code: 500,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
}
]
}
]
},
{
name: "Start a backup process",
request: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "id": "<string>",
  "config": {
    "CPUPercentage": 50,
    "ChunkSize": 128,
    "CompressionLevel": "DefaultCompression"
  },
  "include": [
    "<string>",
    "<string>"
  ],
  "exclude": [
    "<string>",
    "<string>"
  ]
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/backups/:backend",
host: [
"{{baseUrl}}"
],
path: [
"backups",
":backend"
],
variable: [
{
key: "backend",
value: "<string>",
description: "(Required) Backup backend name e.g. `filesystem`, `gcs`, `s3`, `azure`."
}
]
},
description: "Start creating a backup for a set of collections. <br/><br/>Notes: <br/>- Weaviate uses gzip compression by default. <br/>- Weaviate stays usable while a backup process is ongoing."
},
response: [
{
name: "Backup create process successfully started.",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "id": "<string>",
  "config": {
    "CPUPercentage": 50,
    "ChunkSize": 128,
    "CompressionLevel": "DefaultCompression"
  },
  "include": [
    "<string>",
    "<string>"
  ],
  "exclude": [
    "<string>",
    "<string>"
  ]
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/backups/:backend",
host: [
"{{baseUrl}}"
],
path: [
"backups",
":backend"
],
variable: [
{
key: "backend"
}
]
}
},
status: "OK",
code: 200,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "id": "<string>",
  "classes": [
    "<string>",
    "<string>"
  ],
  "backend": "<string>",
  "path": "<string>",
  "error": "<string>",
  "status": "STARTED"
}"
},
{
name: "Unauthorized or invalid credentials.",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "id": "<string>",
  "config": {
    "CPUPercentage": 50,
    "ChunkSize": 128,
    "CompressionLevel": "DefaultCompression"
  },
  "include": [
    "<string>",
    "<string>"
  ],
  "exclude": [
    "<string>",
    "<string>"
  ]
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/backups/:backend",
host: [
"{{baseUrl}}"
],
path: [
"backups",
":backend"
],
variable: [
{
key: "backend"
}
]
}
},
status: "Unauthorized",
code: 401,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Forbidden",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "id": "<string>",
  "config": {
    "CPUPercentage": 50,
    "ChunkSize": 128,
    "CompressionLevel": "DefaultCompression"
  },
  "include": [
    "<string>",
    "<string>"
  ],
  "exclude": [
    "<string>",
    "<string>"
  ]
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/backups/:backend",
host: [
"{{baseUrl}}"
],
path: [
"backups",
":backend"
],
variable: [
{
key: "backend"
}
]
}
},
status: "Forbidden",
code: 403,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Invalid backup creation attempt.",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "id": "<string>",
  "config": {
    "CPUPercentage": 50,
    "ChunkSize": 128,
    "CompressionLevel": "DefaultCompression"
  },
  "include": [
    "<string>",
    "<string>"
  ],
  "exclude": [
    "<string>",
    "<string>"
  ]
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/backups/:backend",
host: [
"{{baseUrl}}"
],
path: [
"backups",
":backend"
],
variable: [
{
key: "backend"
}
]
}
},
status: "Unprocessable Entity (WebDAV) (RFC 4918)",
code: 422,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error.",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "id": "<string>",
  "config": {
    "CPUPercentage": 50,
    "ChunkSize": 128,
    "CompressionLevel": "DefaultCompression"
  },
  "include": [
    "<string>",
    "<string>"
  ],
  "exclude": [
    "<string>",
    "<string>"
  ]
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/backups/:backend",
host: [
"{{baseUrl}}"
],
path: [
"backups",
":backend"
],
variable: [
{
key: "backend"
}
]
}
},
status: "Internal Server Error",
code: 500,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
}
]
}
]
}
]
},
{
name: "cluster",
item: [
{
name: "statistics",
item: [
{
name: "See Raft cluster statistics",
request: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/cluster/statistics",
host: [
"{{baseUrl}}"
],
path: [
"cluster",
"statistics"
]
},
description: "Returns Raft cluster statistics of Weaviate DB."
},
response: [
{
name: "Cluster statistics successfully returned",
originalRequest: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/cluster/statistics",
host: [
"{{baseUrl}}"
],
path: [
"cluster",
"statistics"
]
}
},
status: "OK",
code: 200,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "statistics": [
    {
      "name": "<string>",
      "status": "HEALTHY",
      "bootstrapped": "<boolean>",
      "dbLoaded": "<boolean>",
      "initialLastAppliedIndex": "<number>",
      "lastAppliedIndex": "<number>",
      "isVoter": "<boolean>",
      "leaderId": {},
      "leaderAddress": {},
      "open": "<boolean>",
      "ready": "<boolean>",
      "candidates": {},
      "raft": {
        "appliedIndex": "<string>",
        "commitIndex": "<string>",
        "fsmPending": "<string>",
        "lastContact": "<string>",
        "lastLogIndex": "<string>",
        "lastLogTerm": "<string>",
        "lastSnapshotIndex": "<string>",
        "lastSnapshotTerm": "<string>",
        "latestConfiguration": {},
        "latestConfigurationIndex": "<string>",
        "numPeers": "<string>",
        "protocolVersion": "<string>",
        "protocolVersionMax": "<string>",
        "protocolVersionMin": "<string>",
        "snapshotVersionMax": "<string>",
        "snapshotVersionMin": "<string>",
        "state": "<string>",
        "term": "<string>"
      }
    },
    {
      "name": "<string>",
      "status": "HEALTHY",
      "bootstrapped": "<boolean>",
      "dbLoaded": "<boolean>",
      "initialLastAppliedIndex": "<number>",
      "lastAppliedIndex": "<number>",
      "isVoter": "<boolean>",
      "leaderId": {},
      "leaderAddress": {},
      "open": "<boolean>",
      "ready": "<boolean>",
      "candidates": {},
      "raft": {
        "appliedIndex": "<string>",
        "commitIndex": "<string>",
        "fsmPending": "<string>",
        "lastContact": "<string>",
        "lastLogIndex": "<string>",
        "lastLogTerm": "<string>",
        "lastSnapshotIndex": "<string>",
        "lastSnapshotTerm": "<string>",
        "latestConfiguration": {},
        "latestConfigurationIndex": "<string>",
        "numPeers": "<string>",
        "protocolVersion": "<string>",
        "protocolVersionMax": "<string>",
        "protocolVersionMin": "<string>",
        "snapshotVersionMax": "<string>",
        "snapshotVersionMin": "<string>",
        "state": "<string>",
        "term": "<string>"
      }
    }
  ],
  "synchronized": "<boolean>"
}"
},
{
name: "Unauthorized or invalid credentials.",
originalRequest: {
method: "GET",
header: [ ],
url: {
raw: "{{baseUrl}}/cluster/statistics",
host: [
"{{baseUrl}}"
],
path: [
"cluster",
"statistics"
]
}
},
status: "Unauthorized",
code: 401,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Forbidden",
originalRequest: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/cluster/statistics",
host: [
"{{baseUrl}}"
],
path: [
"cluster",
"statistics"
]
}
},
status: "Forbidden",
code: 403,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Invalid backup restoration status attempt.",
originalRequest: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/cluster/statistics",
host: [
"{{baseUrl}}"
],
path: [
"cluster",
"statistics"
]
}
},
status: "Unprocessable Entity (WebDAV) (RFC 4918)",
code: 422,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error.",
originalRequest: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/cluster/statistics",
host: [
"{{baseUrl}}"
],
path: [
"cluster",
"statistics"
]
}
},
status: "Internal Server Error",
code: 500,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
}
]
}
]
}
]
},
{
name: "nodes",
item: [
{
name: "{className}",
item: [
{
name: "Node information for a collection.",
request: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/nodes/:className?output=minimal",
host: [
"{{baseUrl}}"
],
path: [
"nodes",
":className"
],
query: [
{
key: "output",
value: "minimal",
description: "Controls the verbosity of the output."
}
],
variable: [
{
key: "className",
value: "<string>",
description: "(Required) "
}
]
},
description: "Returns node information for the nodes relevant to the collection."
},
response: [
{
name: "Nodes status successfully returned",
originalRequest: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/nodes/:className?output=minimal",
host: [
"{{baseUrl}}"
],
path: [
"nodes",
":className"
],
query: [
{
key: "output",
value: "minimal",
description: "Controls the verbosity of the output."
}
],
variable: [
{
key: "className"
}
]
}
},
status: "OK",
code: 200,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "nodes": [
    {
      "name": "<string>",
      "status": "HEALTHY",
      "version": "<string>",
      "gitHash": "<string>",
      "stats": {
        "shardCount": "<number>",
        "objectCount": "<number>"
      },
      "batchStats": {
        "queueLength": "<number>",
        "ratePerSecond": "<number>"
      },
      "shards": [
        {
          "name": "<string>",
          "class": "<string>",
          "objectCount": "<number>",
          "vectorIndexingStatus": {
            "description": "The status of the vector indexing process.",
            "x-omitempty": false
          },
          "compressed": {
            "description": "The status of vector compression/quantization.",
            "x-omitempty": false
          },
          "vectorQueueLength": "<number>",
          "loaded": "<boolean>"
        },
        {
          "name": "<string>",
          "class": "<string>",
          "objectCount": "<number>",
          "vectorIndexingStatus": {
            "description": "The status of the vector indexing process.",
            "x-omitempty": false
          },
          "compressed": {
            "description": "The status of vector compression/quantization.",
            "x-omitempty": false
          },
          "vectorQueueLength": "<number>",
          "loaded": "<boolean>"
        }
      ]
    },
    {
      "name": "<string>",
      "status": "HEALTHY",
      "version": "<string>",
      "gitHash": "<string>",
      "stats": {
        "shardCount": "<number>",
        "objectCount": "<number>"
      },
      "batchStats": {
        "queueLength": "<number>",
        "ratePerSecond": "<number>"
      },
      "shards": [
        {
          "name": "<string>",
          "class": "<string>",
          "objectCount": "<number>",
          "vectorIndexingStatus": {
            "description": "The status of the vector indexing process.",
            "x-omitempty": false
          },
          "compressed": {
            "description": "The status of vector compression/quantization.",
            "x-omitempty": false
          },
          "vectorQueueLength": "<number>",
          "loaded": "<boolean>"
        },
        {
          "name": "<string>",
          "class": "<string>",
          "objectCount": "<number>",
          "vectorIndexingStatus": {
            "description": "The status of the vector indexing process.",
            "x-omitempty": false
          },
          "compressed": {
            "description": "The status of vector compression/quantization.",
            "x-omitempty": false
          },
          "vectorQueueLength": "<number>",
          "loaded": "<boolean>"
        }
      ]
    }
  ]
}"
},
{
name: "Unauthorized or invalid credentials.",
originalRequest: {
method: "GET",
header: [ ],
url: {
raw: "{{baseUrl}}/nodes/:className?output=minimal",
host: [
"{{baseUrl}}"
],
path: [
"nodes",
":className"
],
query: [
{
key: "output",
value: "minimal",
description: "Controls the verbosity of the output."
}
],
variable: [
{
key: "className"
}
]
}
},
status: "Unauthorized",
code: 401,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Forbidden",
originalRequest: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/nodes/:className?output=minimal",
host: [
"{{baseUrl}}"
],
path: [
"nodes",
":className"
],
query: [
{
key: "output",
value: "minimal",
description: "Controls the verbosity of the output."
}
],
variable: [
{
key: "className"
}
]
}
},
status: "Forbidden",
code: 403,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Not Found - Backup does not exist",
originalRequest: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/nodes/:className?output=minimal",
host: [
"{{baseUrl}}"
],
path: [
"nodes",
":className"
],
query: [
{
key: "output",
value: "minimal",
description: "Controls the verbosity of the output."
}
],
variable: [
{
key: "className"
}
]
}
},
status: "Not Found",
code: 404,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Invalid backup restoration status attempt.",
originalRequest: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/nodes/:className?output=minimal",
host: [
"{{baseUrl}}"
],
path: [
"nodes",
":className"
],
query: [
{
key: "output",
value: "minimal",
description: "Controls the verbosity of the output."
}
],
variable: [
{
key: "className"
}
]
}
},
status: "Unprocessable Entity (WebDAV) (RFC 4918)",
code: 422,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error.",
originalRequest: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/nodes/:className?output=minimal",
host: [
"{{baseUrl}}"
],
path: [
"nodes",
":className"
],
query: [
{
key: "output",
value: "minimal",
description: "Controls the verbosity of the output."
}
],
variable: [
{
key: "className"
}
]
}
},
status: "Internal Server Error",
code: 500,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
}
]
}
]
},
{
name: "Node information for the database.",
request: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/nodes?output=minimal",
host: [
"{{baseUrl}}"
],
path: [
"nodes"
],
query: [
{
key: "output",
value: "minimal",
description: "Controls the verbosity of the output."
}
]
},
description: "Returns node information for the entire database."
},
response: [
{
name: "Nodes status successfully returned",
originalRequest: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/nodes?output=minimal",
host: [
"{{baseUrl}}"
],
path: [
"nodes"
],
query: [
{
key: "output",
value: "minimal",
description: "Controls the verbosity of the output."
}
]
}
},
status: "OK",
code: 200,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "nodes": [
    {
      "name": "<string>",
      "status": "HEALTHY",
      "version": "<string>",
      "gitHash": "<string>",
      "stats": {
        "shardCount": "<number>",
        "objectCount": "<number>"
      },
      "batchStats": {
        "queueLength": "<number>",
        "ratePerSecond": "<number>"
      },
      "shards": [
        {
          "name": "<string>",
          "class": "<string>",
          "objectCount": "<number>",
          "vectorIndexingStatus": {
            "description": "The status of the vector indexing process.",
            "x-omitempty": false
          },
          "compressed": {
            "description": "The status of vector compression/quantization.",
            "x-omitempty": false
          },
          "vectorQueueLength": "<number>",
          "loaded": "<boolean>"
        },
        {
          "name": "<string>",
          "class": "<string>",
          "objectCount": "<number>",
          "vectorIndexingStatus": {
            "description": "The status of the vector indexing process.",
            "x-omitempty": false
          },
          "compressed": {
            "description": "The status of vector compression/quantization.",
            "x-omitempty": false
          },
          "vectorQueueLength": "<number>",
          "loaded": "<boolean>"
        }
      ]
    },
    {
      "name": "<string>",
      "status": "HEALTHY",
      "version": "<string>",
      "gitHash": "<string>",
      "stats": {
        "shardCount": "<number>",
        "objectCount": "<number>"
      },
      "batchStats": {
        "queueLength": "<number>",
        "ratePerSecond": "<number>"
      },
      "shards": [
        {
          "name": "<string>",
          "class": "<string>",
          "objectCount": "<number>",
          "vectorIndexingStatus": {
            "description": "The status of the vector indexing process.",
            "x-omitempty": false
          },
          "compressed": {
            "description": "The status of vector compression/quantization.",
            "x-omitempty": false
          },
          "vectorQueueLength": "<number>",
          "loaded": "<boolean>"
        },
        {
          "name": "<string>",
          "class": "<string>",
          "objectCount": "<number>",
          "vectorIndexingStatus": {
            "description": "The status of the vector indexing process.",
            "x-omitempty": false
          },
          "compressed": {
            "description": "The status of vector compression/quantization.",
            "x-omitempty": false
          },
          "vectorQueueLength": "<number>",
          "loaded": "<boolean>"
        }
      ]
    }
  ]
}"
},
{
name: "Unauthorized or invalid credentials.",
originalRequest: {
method: "GET",
header: [ ],
url: {
raw: "{{baseUrl}}/nodes?output=minimal",
host: [
"{{baseUrl}}"
],
path: [
"nodes"
],
query: [
{
key: "output",
value: "minimal",
description: "Controls the verbosity of the output."
}
]
}
},
status: "Unauthorized",
code: 401,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Forbidden",
originalRequest: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/nodes?output=minimal",
host: [
"{{baseUrl}}"
],
path: [
"nodes"
],
query: [
{
key: "output",
value: "minimal",
description: "Controls the verbosity of the output."
}
]
}
},
status: "Forbidden",
code: 403,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Not Found - Backup does not exist",
originalRequest: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/nodes?output=minimal",
host: [
"{{baseUrl}}"
],
path: [
"nodes"
],
query: [
{
key: "output",
value: "minimal",
description: "Controls the verbosity of the output."
}
]
}
},
status: "Not Found",
code: 404,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Invalid backup restoration status attempt.",
originalRequest: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/nodes?output=minimal",
host: [
"{{baseUrl}}"
],
path: [
"nodes"
],
query: [
{
key: "output",
value: "minimal",
description: "Controls the verbosity of the output."
}
]
}
},
status: "Unprocessable Entity (WebDAV) (RFC 4918)",
code: 422,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error.",
originalRequest: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/nodes?output=minimal",
host: [
"{{baseUrl}}"
],
path: [
"nodes"
],
query: [
{
key: "output",
value: "minimal",
description: "Controls the verbosity of the output."
}
]
}
},
status: "Internal Server Error",
code: 500,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
}
]
}
]
},
{
name: "classifications",
item: [
{
name: "{id}",
item: [
{
name: "View previously created classification",
request: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/classifications/:id",
host: [
"{{baseUrl}}"
],
path: [
"classifications",
":id"
],
variable: [
{
key: "id",
value: "<string>",
description: "(Required) classification id"
}
]
},
description: "Get status, results and metadata of a previously created classification"
},
response: [
{
name: "Found the classification, returned as body",
originalRequest: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/classifications/:id",
host: [
"{{baseUrl}}"
],
path: [
"classifications",
":id"
],
variable: [
{
key: "id"
}
]
}
},
status: "OK",
code: 200,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "id": "<uuid>",
  "class": "<string>",
  "classifyProperties": [
    "<string>",
    "<string>"
  ],
  "basedOnProperties": [
    "<string>",
    "<string>"
  ],
  "status": "running",
  "meta": {
    "started": "<dateTime>",
    "completed": "<dateTime>",
    "count": "<integer>",
    "countSucceeded": "<integer>",
    "countFailed": "<integer>"
  },
  "type": "<string>",
  "settings": {},
  "error": "",
  "filters": {
    "sourceWhere": {
      "operands": [
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        },
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        }
      ],
      "operator": "WithinGeoRange",
      "path": [
        "<string>",
        "<string>"
      ],
      "valueInt": "<long>",
      "valueNumber": "<number>",
      "valueBoolean": "<boolean>",
      "valueString": "<string>",
      "valueText": "<string>",
      "valueDate": "<string>",
      "valueIntArray": [
        "<long>",
        "<long>"
      ],
      "valueNumberArray": [
        "<number>",
        "<number>"
      ],
      "valueBooleanArray": [
        "<boolean>",
        "<boolean>"
      ],
      "valueStringArray": [
        "<string>",
        "<string>"
      ],
      "valueTextArray": [
        "<string>",
        "<string>"
      ],
      "valueDateArray": [
        "<string>",
        "<string>"
      ],
      "valueGeoRange": {
        "geoCoordinates": {
          "latitude": "<float>",
          "longitude": "<float>"
        },
        "distance": {
          "max": "<number>"
        }
      }
    },
    "trainingSetWhere": {
      "operands": [
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        },
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        }
      ],
      "operator": "Equal",
      "path": [
        "<string>",
        "<string>"
      ],
      "valueInt": "<long>",
      "valueNumber": "<number>",
      "valueBoolean": "<boolean>",
      "valueString": "<string>",
      "valueText": "<string>",
      "valueDate": "<string>",
      "valueIntArray": [
        "<long>",
        "<long>"
      ],
      "valueNumberArray": [
        "<number>",
        "<number>"
      ],
      "valueBooleanArray": [
        "<boolean>",
        "<boolean>"
      ],
      "valueStringArray": [
        "<string>",
        "<string>"
      ],
      "valueTextArray": [
        "<string>",
        "<string>"
      ],
      "valueDateArray": [
        "<string>",
        "<string>"
      ],
      "valueGeoRange": {
        "geoCoordinates": {
          "latitude": "<float>",
          "longitude": "<float>"
        },
        "distance": {
          "max": "<number>"
        }
      }
    },
    "targetWhere": {
      "operands": [
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        },
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        }
      ],
      "operator": "And",
      "path": [
        "<string>",
        "<string>"
      ],
      "valueInt": "<long>",
      "valueNumber": "<number>",
      "valueBoolean": "<boolean>",
      "valueString": "<string>",
      "valueText": "<string>",
      "valueDate": "<string>",
      "valueIntArray": [
        "<long>",
        "<long>"
      ],
      "valueNumberArray": [
        "<number>",
        "<number>"
      ],
      "valueBooleanArray": [
        "<boolean>",
        "<boolean>"
      ],
      "valueStringArray": [
        "<string>",
        "<string>"
      ],
      "valueTextArray": [
        "<string>",
        "<string>"
      ],
      "valueDateArray": [
        "<string>",
        "<string>"
      ],
      "valueGeoRange": {
        "geoCoordinates": {
          "latitude": "<float>",
          "longitude": "<float>"
        },
        "distance": {
          "max": "<number>"
        }
      }
    }
  }
}"
},
{
name: "Unauthorized or invalid credentials.",
originalRequest: {
method: "GET",
header: [ ],
url: {
raw: "{{baseUrl}}/classifications/:id",
host: [
"{{baseUrl}}"
],
path: [
"classifications",
":id"
],
variable: [
{
key: "id"
}
]
}
},
status: "Unauthorized",
code: 401,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Forbidden",
originalRequest: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/classifications/:id",
host: [
"{{baseUrl}}"
],
path: [
"classifications",
":id"
],
variable: [
{
key: "id"
}
]
}
},
status: "Forbidden",
code: 403,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Not Found - Classification does not exist",
originalRequest: {
method: "GET",
header: [ ],
url: {
raw: "{{baseUrl}}/classifications/:id",
host: [
"{{baseUrl}}"
],
path: [
"classifications",
":id"
],
variable: [
{
key: "id"
}
]
}
},
status: "Not Found",
code: 404,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error.",
originalRequest: {
method: "GET",
header: [
{
key: "Accept",
value: "application/json"
}
],
url: {
raw: "{{baseUrl}}/classifications/:id",
host: [
"{{baseUrl}}"
],
path: [
"classifications",
":id"
],
variable: [
{
key: "id"
}
]
}
},
status: "Internal Server Error",
code: 500,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
}
]
}
]
},
{
name: "Starts a classification.",
request: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "id": "<uuid>",
  "class": "<string>",
  "classifyProperties": [
    "<string>",
    "<string>"
  ],
  "basedOnProperties": [
    "<string>",
    "<string>"
  ],
  "status": "running",
  "meta": {
    "started": "<dateTime>",
    "completed": "<dateTime>",
    "count": "<integer>",
    "countSucceeded": "<integer>",
    "countFailed": "<integer>"
  },
  "type": "<string>",
  "settings": {},
  "error": "",
  "filters": {
    "sourceWhere": {
      "operands": [
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        },
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        }
      ],
      "operator": "WithinGeoRange",
      "path": [
        "<string>",
        "<string>"
      ],
      "valueInt": "<long>",
      "valueNumber": "<number>",
      "valueBoolean": "<boolean>",
      "valueString": "<string>",
      "valueText": "<string>",
      "valueDate": "<string>",
      "valueIntArray": [
        "<long>",
        "<long>"
      ],
      "valueNumberArray": [
        "<number>",
        "<number>"
      ],
      "valueBooleanArray": [
        "<boolean>",
        "<boolean>"
      ],
      "valueStringArray": [
        "<string>",
        "<string>"
      ],
      "valueTextArray": [
        "<string>",
        "<string>"
      ],
      "valueDateArray": [
        "<string>",
        "<string>"
      ],
      "valueGeoRange": {
        "geoCoordinates": {
          "latitude": "<float>",
          "longitude": "<float>"
        },
        "distance": {
          "max": "<number>"
        }
      }
    },
    "trainingSetWhere": {
      "operands": [
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        },
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        }
      ],
      "operator": "Equal",
      "path": [
        "<string>",
        "<string>"
      ],
      "valueInt": "<long>",
      "valueNumber": "<number>",
      "valueBoolean": "<boolean>",
      "valueString": "<string>",
      "valueText": "<string>",
      "valueDate": "<string>",
      "valueIntArray": [
        "<long>",
        "<long>"
      ],
      "valueNumberArray": [
        "<number>",
        "<number>"
      ],
      "valueBooleanArray": [
        "<boolean>",
        "<boolean>"
      ],
      "valueStringArray": [
        "<string>",
        "<string>"
      ],
      "valueTextArray": [
        "<string>",
        "<string>"
      ],
      "valueDateArray": [
        "<string>",
        "<string>"
      ],
      "valueGeoRange": {
        "geoCoordinates": {
          "latitude": "<float>",
          "longitude": "<float>"
        },
        "distance": {
          "max": "<number>"
        }
      }
    },
    "targetWhere": {
      "operands": [
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        },
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        }
      ],
      "operator": "And",
      "path": [
        "<string>",
        "<string>"
      ],
      "valueInt": "<long>",
      "valueNumber": "<number>",
      "valueBoolean": "<boolean>",
      "valueString": "<string>",
      "valueText": "<string>",
      "valueDate": "<string>",
      "valueIntArray": [
        "<long>",
        "<long>"
      ],
      "valueNumberArray": [
        "<number>",
        "<number>"
      ],
      "valueBooleanArray": [
        "<boolean>",
        "<boolean>"
      ],
      "valueStringArray": [
        "<string>",
        "<string>"
      ],
      "valueTextArray": [
        "<string>",
        "<string>"
      ],
      "valueDateArray": [
        "<string>",
        "<string>"
      ],
      "valueGeoRange": {
        "geoCoordinates": {
          "latitude": "<float>",
          "longitude": "<float>"
        },
        "distance": {
          "max": "<number>"
        }
      }
    }
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/classifications/",
host: [
"{{baseUrl}}"
],
path: [
"classifications",
""
]
},
description: "Trigger a classification based on the specified params. Classifications will run in the background, use GET /classifications/<id> to retrieve the status of your classification."
},
response: [
{
name: "Successfully started classification.",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "id": "<uuid>",
  "class": "<string>",
  "classifyProperties": [
    "<string>",
    "<string>"
  ],
  "basedOnProperties": [
    "<string>",
    "<string>"
  ],
  "status": "running",
  "meta": {
    "started": "<dateTime>",
    "completed": "<dateTime>",
    "count": "<integer>",
    "countSucceeded": "<integer>",
    "countFailed": "<integer>"
  },
  "type": "<string>",
  "settings": {},
  "error": "",
  "filters": {
    "sourceWhere": {
      "operands": [
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        },
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        }
      ],
      "operator": "WithinGeoRange",
      "path": [
        "<string>",
        "<string>"
      ],
      "valueInt": "<long>",
      "valueNumber": "<number>",
      "valueBoolean": "<boolean>",
      "valueString": "<string>",
      "valueText": "<string>",
      "valueDate": "<string>",
      "valueIntArray": [
        "<long>",
        "<long>"
      ],
      "valueNumberArray": [
        "<number>",
        "<number>"
      ],
      "valueBooleanArray": [
        "<boolean>",
        "<boolean>"
      ],
      "valueStringArray": [
        "<string>",
        "<string>"
      ],
      "valueTextArray": [
        "<string>",
        "<string>"
      ],
      "valueDateArray": [
        "<string>",
        "<string>"
      ],
      "valueGeoRange": {
        "geoCoordinates": {
          "latitude": "<float>",
          "longitude": "<float>"
        },
        "distance": {
          "max": "<number>"
        }
      }
    },
    "trainingSetWhere": {
      "operands": [
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        },
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        }
      ],
      "operator": "Equal",
      "path": [
        "<string>",
        "<string>"
      ],
      "valueInt": "<long>",
      "valueNumber": "<number>",
      "valueBoolean": "<boolean>",
      "valueString": "<string>",
      "valueText": "<string>",
      "valueDate": "<string>",
      "valueIntArray": [
        "<long>",
        "<long>"
      ],
      "valueNumberArray": [
        "<number>",
        "<number>"
      ],
      "valueBooleanArray": [
        "<boolean>",
        "<boolean>"
      ],
      "valueStringArray": [
        "<string>",
        "<string>"
      ],
      "valueTextArray": [
        "<string>",
        "<string>"
      ],
      "valueDateArray": [
        "<string>",
        "<string>"
      ],
      "valueGeoRange": {
        "geoCoordinates": {
          "latitude": "<float>",
          "longitude": "<float>"
        },
        "distance": {
          "max": "<number>"
        }
      }
    },
    "targetWhere": {
      "operands": [
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        },
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        }
      ],
      "operator": "And",
      "path": [
        "<string>",
        "<string>"
      ],
      "valueInt": "<long>",
      "valueNumber": "<number>",
      "valueBoolean": "<boolean>",
      "valueString": "<string>",
      "valueText": "<string>",
      "valueDate": "<string>",
      "valueIntArray": [
        "<long>",
        "<long>"
      ],
      "valueNumberArray": [
        "<number>",
        "<number>"
      ],
      "valueBooleanArray": [
        "<boolean>",
        "<boolean>"
      ],
      "valueStringArray": [
        "<string>",
        "<string>"
      ],
      "valueTextArray": [
        "<string>",
        "<string>"
      ],
      "valueDateArray": [
        "<string>",
        "<string>"
      ],
      "valueGeoRange": {
        "geoCoordinates": {
          "latitude": "<float>",
          "longitude": "<float>"
        },
        "distance": {
          "max": "<number>"
        }
      }
    }
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/classifications/",
host: [
"{{baseUrl}}"
],
path: [
"classifications",
""
]
}
},
status: "Created",
code: 201,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "id": "<uuid>",
  "class": "<string>",
  "classifyProperties": [
    "<string>",
    "<string>"
  ],
  "basedOnProperties": [
    "<string>",
    "<string>"
  ],
  "status": "running",
  "meta": {
    "started": "<dateTime>",
    "completed": "<dateTime>",
    "count": "<integer>",
    "countSucceeded": "<integer>",
    "countFailed": "<integer>"
  },
  "type": "<string>",
  "settings": {},
  "error": "",
  "filters": {
    "sourceWhere": {
      "operands": [
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        },
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        }
      ],
      "operator": "WithinGeoRange",
      "path": [
        "<string>",
        "<string>"
      ],
      "valueInt": "<long>",
      "valueNumber": "<number>",
      "valueBoolean": "<boolean>",
      "valueString": "<string>",
      "valueText": "<string>",
      "valueDate": "<string>",
      "valueIntArray": [
        "<long>",
        "<long>"
      ],
      "valueNumberArray": [
        "<number>",
        "<number>"
      ],
      "valueBooleanArray": [
        "<boolean>",
        "<boolean>"
      ],
      "valueStringArray": [
        "<string>",
        "<string>"
      ],
      "valueTextArray": [
        "<string>",
        "<string>"
      ],
      "valueDateArray": [
        "<string>",
        "<string>"
      ],
      "valueGeoRange": {
        "geoCoordinates": {
          "latitude": "<float>",
          "longitude": "<float>"
        },
        "distance": {
          "max": "<number>"
        }
      }
    },
    "trainingSetWhere": {
      "operands": [
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        },
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        }
      ],
      "operator": "Equal",
      "path": [
        "<string>",
        "<string>"
      ],
      "valueInt": "<long>",
      "valueNumber": "<number>",
      "valueBoolean": "<boolean>",
      "valueString": "<string>",
      "valueText": "<string>",
      "valueDate": "<string>",
      "valueIntArray": [
        "<long>",
        "<long>"
      ],
      "valueNumberArray": [
        "<number>",
        "<number>"
      ],
      "valueBooleanArray": [
        "<boolean>",
        "<boolean>"
      ],
      "valueStringArray": [
        "<string>",
        "<string>"
      ],
      "valueTextArray": [
        "<string>",
        "<string>"
      ],
      "valueDateArray": [
        "<string>",
        "<string>"
      ],
      "valueGeoRange": {
        "geoCoordinates": {
          "latitude": "<float>",
          "longitude": "<float>"
        },
        "distance": {
          "max": "<number>"
        }
      }
    },
    "targetWhere": {
      "operands": [
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        },
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        }
      ],
      "operator": "And",
      "path": [
        "<string>",
        "<string>"
      ],
      "valueInt": "<long>",
      "valueNumber": "<number>",
      "valueBoolean": "<boolean>",
      "valueString": "<string>",
      "valueText": "<string>",
      "valueDate": "<string>",
      "valueIntArray": [
        "<long>",
        "<long>"
      ],
      "valueNumberArray": [
        "<number>",
        "<number>"
      ],
      "valueBooleanArray": [
        "<boolean>",
        "<boolean>"
      ],
      "valueStringArray": [
        "<string>",
        "<string>"
      ],
      "valueTextArray": [
        "<string>",
        "<string>"
      ],
      "valueDateArray": [
        "<string>",
        "<string>"
      ],
      "valueGeoRange": {
        "geoCoordinates": {
          "latitude": "<float>",
          "longitude": "<float>"
        },
        "distance": {
          "max": "<number>"
        }
      }
    }
  }
}"
},
{
name: "Incorrect request",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "id": "<uuid>",
  "class": "<string>",
  "classifyProperties": [
    "<string>",
    "<string>"
  ],
  "basedOnProperties": [
    "<string>",
    "<string>"
  ],
  "status": "running",
  "meta": {
    "started": "<dateTime>",
    "completed": "<dateTime>",
    "count": "<integer>",
    "countSucceeded": "<integer>",
    "countFailed": "<integer>"
  },
  "type": "<string>",
  "settings": {},
  "error": "",
  "filters": {
    "sourceWhere": {
      "operands": [
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        },
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        }
      ],
      "operator": "WithinGeoRange",
      "path": [
        "<string>",
        "<string>"
      ],
      "valueInt": "<long>",
      "valueNumber": "<number>",
      "valueBoolean": "<boolean>",
      "valueString": "<string>",
      "valueText": "<string>",
      "valueDate": "<string>",
      "valueIntArray": [
        "<long>",
        "<long>"
      ],
      "valueNumberArray": [
        "<number>",
        "<number>"
      ],
      "valueBooleanArray": [
        "<boolean>",
        "<boolean>"
      ],
      "valueStringArray": [
        "<string>",
        "<string>"
      ],
      "valueTextArray": [
        "<string>",
        "<string>"
      ],
      "valueDateArray": [
        "<string>",
        "<string>"
      ],
      "valueGeoRange": {
        "geoCoordinates": {
          "latitude": "<float>",
          "longitude": "<float>"
        },
        "distance": {
          "max": "<number>"
        }
      }
    },
    "trainingSetWhere": {
      "operands": [
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        },
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        }
      ],
      "operator": "Equal",
      "path": [
        "<string>",
        "<string>"
      ],
      "valueInt": "<long>",
      "valueNumber": "<number>",
      "valueBoolean": "<boolean>",
      "valueString": "<string>",
      "valueText": "<string>",
      "valueDate": "<string>",
      "valueIntArray": [
        "<long>",
        "<long>"
      ],
      "valueNumberArray": [
        "<number>",
        "<number>"
      ],
      "valueBooleanArray": [
        "<boolean>",
        "<boolean>"
      ],
      "valueStringArray": [
        "<string>",
        "<string>"
      ],
      "valueTextArray": [
        "<string>",
        "<string>"
      ],
      "valueDateArray": [
        "<string>",
        "<string>"
      ],
      "valueGeoRange": {
        "geoCoordinates": {
          "latitude": "<float>",
          "longitude": "<float>"
        },
        "distance": {
          "max": "<number>"
        }
      }
    },
    "targetWhere": {
      "operands": [
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        },
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        }
      ],
      "operator": "And",
      "path": [
        "<string>",
        "<string>"
      ],
      "valueInt": "<long>",
      "valueNumber": "<number>",
      "valueBoolean": "<boolean>",
      "valueString": "<string>",
      "valueText": "<string>",
      "valueDate": "<string>",
      "valueIntArray": [
        "<long>",
        "<long>"
      ],
      "valueNumberArray": [
        "<number>",
        "<number>"
      ],
      "valueBooleanArray": [
        "<boolean>",
        "<boolean>"
      ],
      "valueStringArray": [
        "<string>",
        "<string>"
      ],
      "valueTextArray": [
        "<string>",
        "<string>"
      ],
      "valueDateArray": [
        "<string>",
        "<string>"
      ],
      "valueGeoRange": {
        "geoCoordinates": {
          "latitude": "<float>",
          "longitude": "<float>"
        },
        "distance": {
          "max": "<number>"
        }
      }
    }
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/classifications/",
host: [
"{{baseUrl}}"
],
path: [
"classifications",
""
]
}
},
status: "Bad Request",
code: 400,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "Unauthorized or invalid credentials.",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "id": "<uuid>",
  "class": "<string>",
  "classifyProperties": [
    "<string>",
    "<string>"
  ],
  "basedOnProperties": [
    "<string>",
    "<string>"
  ],
  "status": "running",
  "meta": {
    "started": "<dateTime>",
    "completed": "<dateTime>",
    "count": "<integer>",
    "countSucceeded": "<integer>",
    "countFailed": "<integer>"
  },
  "type": "<string>",
  "settings": {},
  "error": "",
  "filters": {
    "sourceWhere": {
      "operands": [
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        },
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        }
      ],
      "operator": "WithinGeoRange",
      "path": [
        "<string>",
        "<string>"
      ],
      "valueInt": "<long>",
      "valueNumber": "<number>",
      "valueBoolean": "<boolean>",
      "valueString": "<string>",
      "valueText": "<string>",
      "valueDate": "<string>",
      "valueIntArray": [
        "<long>",
        "<long>"
      ],
      "valueNumberArray": [
        "<number>",
        "<number>"
      ],
      "valueBooleanArray": [
        "<boolean>",
        "<boolean>"
      ],
      "valueStringArray": [
        "<string>",
        "<string>"
      ],
      "valueTextArray": [
        "<string>",
        "<string>"
      ],
      "valueDateArray": [
        "<string>",
        "<string>"
      ],
      "valueGeoRange": {
        "geoCoordinates": {
          "latitude": "<float>",
          "longitude": "<float>"
        },
        "distance": {
          "max": "<number>"
        }
      }
    },
    "trainingSetWhere": {
      "operands": [
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        },
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        }
      ],
      "operator": "Equal",
      "path": [
        "<string>",
        "<string>"
      ],
      "valueInt": "<long>",
      "valueNumber": "<number>",
      "valueBoolean": "<boolean>",
      "valueString": "<string>",
      "valueText": "<string>",
      "valueDate": "<string>",
      "valueIntArray": [
        "<long>",
        "<long>"
      ],
      "valueNumberArray": [
        "<number>",
        "<number>"
      ],
      "valueBooleanArray": [
        "<boolean>",
        "<boolean>"
      ],
      "valueStringArray": [
        "<string>",
        "<string>"
      ],
      "valueTextArray": [
        "<string>",
        "<string>"
      ],
      "valueDateArray": [
        "<string>",
        "<string>"
      ],
      "valueGeoRange": {
        "geoCoordinates": {
          "latitude": "<float>",
          "longitude": "<float>"
        },
        "distance": {
          "max": "<number>"
        }
      }
    },
    "targetWhere": {
      "operands": [
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        },
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        }
      ],
      "operator": "And",
      "path": [
        "<string>",
        "<string>"
      ],
      "valueInt": "<long>",
      "valueNumber": "<number>",
      "valueBoolean": "<boolean>",
      "valueString": "<string>",
      "valueText": "<string>",
      "valueDate": "<string>",
      "valueIntArray": [
        "<long>",
        "<long>"
      ],
      "valueNumberArray": [
        "<number>",
        "<number>"
      ],
      "valueBooleanArray": [
        "<boolean>",
        "<boolean>"
      ],
      "valueStringArray": [
        "<string>",
        "<string>"
      ],
      "valueTextArray": [
        "<string>",
        "<string>"
      ],
      "valueDateArray": [
        "<string>",
        "<string>"
      ],
      "valueGeoRange": {
        "geoCoordinates": {
          "latitude": "<float>",
          "longitude": "<float>"
        },
        "distance": {
          "max": "<number>"
        }
      }
    }
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/classifications/",
host: [
"{{baseUrl}}"
],
path: [
"classifications",
""
]
}
},
status: "Unauthorized",
code: 401,
_postman_previewlanguage: "text",
header: [ ],
cookie: [ ],
body: ""
},
{
name: "Forbidden",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "id": "<uuid>",
  "class": "<string>",
  "classifyProperties": [
    "<string>",
    "<string>"
  ],
  "basedOnProperties": [
    "<string>",
    "<string>"
  ],
  "status": "running",
  "meta": {
    "started": "<dateTime>",
    "completed": "<dateTime>",
    "count": "<integer>",
    "countSucceeded": "<integer>",
    "countFailed": "<integer>"
  },
  "type": "<string>",
  "settings": {},
  "error": "",
  "filters": {
    "sourceWhere": {
      "operands": [
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        },
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        }
      ],
      "operator": "WithinGeoRange",
      "path": [
        "<string>",
        "<string>"
      ],
      "valueInt": "<long>",
      "valueNumber": "<number>",
      "valueBoolean": "<boolean>",
      "valueString": "<string>",
      "valueText": "<string>",
      "valueDate": "<string>",
      "valueIntArray": [
        "<long>",
        "<long>"
      ],
      "valueNumberArray": [
        "<number>",
        "<number>"
      ],
      "valueBooleanArray": [
        "<boolean>",
        "<boolean>"
      ],
      "valueStringArray": [
        "<string>",
        "<string>"
      ],
      "valueTextArray": [
        "<string>",
        "<string>"
      ],
      "valueDateArray": [
        "<string>",
        "<string>"
      ],
      "valueGeoRange": {
        "geoCoordinates": {
          "latitude": "<float>",
          "longitude": "<float>"
        },
        "distance": {
          "max": "<number>"
        }
      }
    },
    "trainingSetWhere": {
      "operands": [
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        },
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        }
      ],
      "operator": "Equal",
      "path": [
        "<string>",
        "<string>"
      ],
      "valueInt": "<long>",
      "valueNumber": "<number>",
      "valueBoolean": "<boolean>",
      "valueString": "<string>",
      "valueText": "<string>",
      "valueDate": "<string>",
      "valueIntArray": [
        "<long>",
        "<long>"
      ],
      "valueNumberArray": [
        "<number>",
        "<number>"
      ],
      "valueBooleanArray": [
        "<boolean>",
        "<boolean>"
      ],
      "valueStringArray": [
        "<string>",
        "<string>"
      ],
      "valueTextArray": [
        "<string>",
        "<string>"
      ],
      "valueDateArray": [
        "<string>",
        "<string>"
      ],
      "valueGeoRange": {
        "geoCoordinates": {
          "latitude": "<float>",
          "longitude": "<float>"
        },
        "distance": {
          "max": "<number>"
        }
      }
    },
    "targetWhere": {
      "operands": [
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        },
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        }
      ],
      "operator": "And",
      "path": [
        "<string>",
        "<string>"
      ],
      "valueInt": "<long>",
      "valueNumber": "<number>",
      "valueBoolean": "<boolean>",
      "valueString": "<string>",
      "valueText": "<string>",
      "valueDate": "<string>",
      "valueIntArray": [
        "<long>",
        "<long>"
      ],
      "valueNumberArray": [
        "<number>",
        "<number>"
      ],
      "valueBooleanArray": [
        "<boolean>",
        "<boolean>"
      ],
      "valueStringArray": [
        "<string>",
        "<string>"
      ],
      "valueTextArray": [
        "<string>",
        "<string>"
      ],
      "valueDateArray": [
        "<string>",
        "<string>"
      ],
      "valueGeoRange": {
        "geoCoordinates": {
          "latitude": "<float>",
          "longitude": "<float>"
        },
        "distance": {
          "max": "<number>"
        }
      }
    }
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/classifications/",
host: [
"{{baseUrl}}"
],
path: [
"classifications",
""
]
}
},
status: "Forbidden",
code: 403,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
},
{
name: "An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error.",
originalRequest: {
method: "POST",
header: [
{
key: "Content-Type",
value: "application/json"
},
{
key: "Accept",
value: "application/json"
}
],
body: {
mode: "raw",
raw: "{
  "id": "<uuid>",
  "class": "<string>",
  "classifyProperties": [
    "<string>",
    "<string>"
  ],
  "basedOnProperties": [
    "<string>",
    "<string>"
  ],
  "status": "running",
  "meta": {
    "started": "<dateTime>",
    "completed": "<dateTime>",
    "count": "<integer>",
    "countSucceeded": "<integer>",
    "countFailed": "<integer>"
  },
  "type": "<string>",
  "settings": {},
  "error": "",
  "filters": {
    "sourceWhere": {
      "operands": [
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        },
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        }
      ],
      "operator": "WithinGeoRange",
      "path": [
        "<string>",
        "<string>"
      ],
      "valueInt": "<long>",
      "valueNumber": "<number>",
      "valueBoolean": "<boolean>",
      "valueString": "<string>",
      "valueText": "<string>",
      "valueDate": "<string>",
      "valueIntArray": [
        "<long>",
        "<long>"
      ],
      "valueNumberArray": [
        "<number>",
        "<number>"
      ],
      "valueBooleanArray": [
        "<boolean>",
        "<boolean>"
      ],
      "valueStringArray": [
        "<string>",
        "<string>"
      ],
      "valueTextArray": [
        "<string>",
        "<string>"
      ],
      "valueDateArray": [
        "<string>",
        "<string>"
      ],
      "valueGeoRange": {
        "geoCoordinates": {
          "latitude": "<float>",
          "longitude": "<float>"
        },
        "distance": {
          "max": "<number>"
        }
      }
    },
    "trainingSetWhere": {
      "operands": [
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        },
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        }
      ],
      "operator": "Equal",
      "path": [
        "<string>",
        "<string>"
      ],
      "valueInt": "<long>",
      "valueNumber": "<number>",
      "valueBoolean": "<boolean>",
      "valueString": "<string>",
      "valueText": "<string>",
      "valueDate": "<string>",
      "valueIntArray": [
        "<long>",
        "<long>"
      ],
      "valueNumberArray": [
        "<number>",
        "<number>"
      ],
      "valueBooleanArray": [
        "<boolean>",
        "<boolean>"
      ],
      "valueStringArray": [
        "<string>",
        "<string>"
      ],
      "valueTextArray": [
        "<string>",
        "<string>"
      ],
      "valueDateArray": [
        "<string>",
        "<string>"
      ],
      "valueGeoRange": {
        "geoCoordinates": {
          "latitude": "<float>",
          "longitude": "<float>"
        },
        "distance": {
          "max": "<number>"
        }
      }
    },
    "targetWhere": {
      "operands": [
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        },
        {
          "value": "<Circular reference to #/components/schemas/WhereFilter detected>"
        }
      ],
      "operator": "And",
      "path": [
        "<string>",
        "<string>"
      ],
      "valueInt": "<long>",
      "valueNumber": "<number>",
      "valueBoolean": "<boolean>",
      "valueString": "<string>",
      "valueText": "<string>",
      "valueDate": "<string>",
      "valueIntArray": [
        "<long>",
        "<long>"
      ],
      "valueNumberArray": [
        "<number>",
        "<number>"
      ],
      "valueBooleanArray": [
        "<boolean>",
        "<boolean>"
      ],
      "valueStringArray": [
        "<string>",
        "<string>"
      ],
      "valueTextArray": [
        "<string>",
        "<string>"
      ],
      "valueDateArray": [
        "<string>",
        "<string>"
      ],
      "valueGeoRange": {
        "geoCoordinates": {
          "latitude": "<float>",
          "longitude": "<float>"
        },
        "distance": {
          "max": "<number>"
        }
      }
    }
  }
}",
options: {
raw: {
headerFamily: "json",
language: "json"
}
}
},
url: {
raw: "{{baseUrl}}/classifications/",
host: [
"{{baseUrl}}"
],
path: [
"classifications",
""
]
}
},
status: "Internal Server Error",
code: 500,
_postman_previewlanguage: "json",
header: [
{
key: "Content-Type",
value: "application/json"
}
],
cookie: [ ],
body: "{
  "error": [
    {
      "message": "<string>"
    },
    {
      "message": "<string>"
    }
  ]
}"
}
]
}
]
}
],
variable: [
{
key: "baseUrl",
value: "http://localhost:9080/v1"
}
]
}
